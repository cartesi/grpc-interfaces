// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cartesi-base.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct Void {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Void {
    fn default() -> &'a Void {
        <Void as ::protobuf::Message>::default_instance()
    }
}

impl Void {
    pub fn new() -> Void {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Void {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Void {
        Void::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Void>(
                    "Void",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Void {
        static mut instance: ::protobuf::lazy::Lazy<Void> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Void,
        };
        unsafe {
            instance.get(Void::new)
        }
    }
}

impl ::protobuf::Clear for Void {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Void {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hash {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "content",
                    |m: &Hash| { &m.content },
                    |m: &mut Hash| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hash>(
                    "Hash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hash {
        static mut instance: ::protobuf::lazy::Lazy<Hash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hash,
        };
        unsafe {
            instance.get(Hash::new)
        }
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProcessorState {
    // message oneof groups
    pub x1_oneof: ::std::option::Option<ProcessorState_oneof_x1_oneof>,
    pub x2_oneof: ::std::option::Option<ProcessorState_oneof_x2_oneof>,
    pub x3_oneof: ::std::option::Option<ProcessorState_oneof_x3_oneof>,
    pub x4_oneof: ::std::option::Option<ProcessorState_oneof_x4_oneof>,
    pub x5_oneof: ::std::option::Option<ProcessorState_oneof_x5_oneof>,
    pub x6_oneof: ::std::option::Option<ProcessorState_oneof_x6_oneof>,
    pub x7_oneof: ::std::option::Option<ProcessorState_oneof_x7_oneof>,
    pub x8_oneof: ::std::option::Option<ProcessorState_oneof_x8_oneof>,
    pub x9_oneof: ::std::option::Option<ProcessorState_oneof_x9_oneof>,
    pub x10_oneof: ::std::option::Option<ProcessorState_oneof_x10_oneof>,
    pub x11_oneof: ::std::option::Option<ProcessorState_oneof_x11_oneof>,
    pub x12_oneof: ::std::option::Option<ProcessorState_oneof_x12_oneof>,
    pub x13_oneof: ::std::option::Option<ProcessorState_oneof_x13_oneof>,
    pub x14_oneof: ::std::option::Option<ProcessorState_oneof_x14_oneof>,
    pub x15_oneof: ::std::option::Option<ProcessorState_oneof_x15_oneof>,
    pub x16_oneof: ::std::option::Option<ProcessorState_oneof_x16_oneof>,
    pub x17_oneof: ::std::option::Option<ProcessorState_oneof_x17_oneof>,
    pub x18_oneof: ::std::option::Option<ProcessorState_oneof_x18_oneof>,
    pub x19_oneof: ::std::option::Option<ProcessorState_oneof_x19_oneof>,
    pub x20_oneof: ::std::option::Option<ProcessorState_oneof_x20_oneof>,
    pub x21_oneof: ::std::option::Option<ProcessorState_oneof_x21_oneof>,
    pub x22_oneof: ::std::option::Option<ProcessorState_oneof_x22_oneof>,
    pub x23_oneof: ::std::option::Option<ProcessorState_oneof_x23_oneof>,
    pub x24_oneof: ::std::option::Option<ProcessorState_oneof_x24_oneof>,
    pub x25_oneof: ::std::option::Option<ProcessorState_oneof_x25_oneof>,
    pub x26_oneof: ::std::option::Option<ProcessorState_oneof_x26_oneof>,
    pub x27_oneof: ::std::option::Option<ProcessorState_oneof_x27_oneof>,
    pub x28_oneof: ::std::option::Option<ProcessorState_oneof_x28_oneof>,
    pub x29_oneof: ::std::option::Option<ProcessorState_oneof_x29_oneof>,
    pub x30_oneof: ::std::option::Option<ProcessorState_oneof_x30_oneof>,
    pub x31_oneof: ::std::option::Option<ProcessorState_oneof_x31_oneof>,
    pub pc_oneof: ::std::option::Option<ProcessorState_oneof_pc_oneof>,
    pub mvendorid_oneof: ::std::option::Option<ProcessorState_oneof_mvendorid_oneof>,
    pub marchid_oneof: ::std::option::Option<ProcessorState_oneof_marchid_oneof>,
    pub mimpid_oneof: ::std::option::Option<ProcessorState_oneof_mimpid_oneof>,
    pub mcycle_oneof: ::std::option::Option<ProcessorState_oneof_mcycle_oneof>,
    pub minstret_oneof: ::std::option::Option<ProcessorState_oneof_minstret_oneof>,
    pub mstatus_oneof: ::std::option::Option<ProcessorState_oneof_mstatus_oneof>,
    pub mtvec_oneof: ::std::option::Option<ProcessorState_oneof_mtvec_oneof>,
    pub mscratch_oneof: ::std::option::Option<ProcessorState_oneof_mscratch_oneof>,
    pub mepc_oneof: ::std::option::Option<ProcessorState_oneof_mepc_oneof>,
    pub mcause_oneof: ::std::option::Option<ProcessorState_oneof_mcause_oneof>,
    pub mtval_oneof: ::std::option::Option<ProcessorState_oneof_mtval_oneof>,
    pub misa_oneof: ::std::option::Option<ProcessorState_oneof_misa_oneof>,
    pub mie_oneof: ::std::option::Option<ProcessorState_oneof_mie_oneof>,
    pub mip_oneof: ::std::option::Option<ProcessorState_oneof_mip_oneof>,
    pub medeleg_oneof: ::std::option::Option<ProcessorState_oneof_medeleg_oneof>,
    pub mideleg_oneof: ::std::option::Option<ProcessorState_oneof_mideleg_oneof>,
    pub mcounteren_oneof: ::std::option::Option<ProcessorState_oneof_mcounteren_oneof>,
    pub stvec_oneof: ::std::option::Option<ProcessorState_oneof_stvec_oneof>,
    pub sscratch_oneof: ::std::option::Option<ProcessorState_oneof_sscratch_oneof>,
    pub sepc_oneof: ::std::option::Option<ProcessorState_oneof_sepc_oneof>,
    pub scause_oneof: ::std::option::Option<ProcessorState_oneof_scause_oneof>,
    pub stval_oneof: ::std::option::Option<ProcessorState_oneof_stval_oneof>,
    pub satp_oneof: ::std::option::Option<ProcessorState_oneof_satp_oneof>,
    pub scounteren_oneof: ::std::option::Option<ProcessorState_oneof_scounteren_oneof>,
    pub ilrsc_oneof: ::std::option::Option<ProcessorState_oneof_ilrsc_oneof>,
    pub iflags_oneof: ::std::option::Option<ProcessorState_oneof_iflags_oneof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProcessorState {
    fn default() -> &'a ProcessorState {
        <ProcessorState as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x1_oneof {
    x1(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x2_oneof {
    x2(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x3_oneof {
    x3(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x4_oneof {
    x4(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x5_oneof {
    x5(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x6_oneof {
    x6(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x7_oneof {
    x7(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x8_oneof {
    x8(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x9_oneof {
    x9(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x10_oneof {
    x10(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x11_oneof {
    x11(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x12_oneof {
    x12(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x13_oneof {
    x13(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x14_oneof {
    x14(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x15_oneof {
    x15(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x16_oneof {
    x16(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x17_oneof {
    x17(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x18_oneof {
    x18(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x19_oneof {
    x19(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x20_oneof {
    x20(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x21_oneof {
    x21(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x22_oneof {
    x22(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x23_oneof {
    x23(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x24_oneof {
    x24(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x25_oneof {
    x25(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x26_oneof {
    x26(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x27_oneof {
    x27(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x28_oneof {
    x28(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x29_oneof {
    x29(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x30_oneof {
    x30(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_x31_oneof {
    x31(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_pc_oneof {
    pc(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mvendorid_oneof {
    mvendorid(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_marchid_oneof {
    marchid(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mimpid_oneof {
    mimpid(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mcycle_oneof {
    mcycle(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_minstret_oneof {
    minstret(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mstatus_oneof {
    mstatus(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mtvec_oneof {
    mtvec(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mscratch_oneof {
    mscratch(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mepc_oneof {
    mepc(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mcause_oneof {
    mcause(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mtval_oneof {
    mtval(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_misa_oneof {
    misa(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mie_oneof {
    mie(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mip_oneof {
    mip(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_medeleg_oneof {
    medeleg(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mideleg_oneof {
    mideleg(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_mcounteren_oneof {
    mcounteren(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_stvec_oneof {
    stvec(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_sscratch_oneof {
    sscratch(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_sepc_oneof {
    sepc(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_scause_oneof {
    scause(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_stval_oneof {
    stval(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_satp_oneof {
    satp(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_scounteren_oneof {
    scounteren(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_ilrsc_oneof {
    ilrsc(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessorState_oneof_iflags_oneof {
    iflags(u64),
}

impl ProcessorState {
    pub fn new() -> ProcessorState {
        ::std::default::Default::default()
    }

    // uint64 x1 = 1;


    pub fn get_x1(&self) -> u64 {
        match self.x1_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x1_oneof::x1(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x1(&mut self) {
        self.x1_oneof = ::std::option::Option::None;
    }

    pub fn has_x1(&self) -> bool {
        match self.x1_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x1_oneof::x1(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x1(&mut self, v: u64) {
        self.x1_oneof = ::std::option::Option::Some(ProcessorState_oneof_x1_oneof::x1(v))
    }

    // uint64 x2 = 2;


    pub fn get_x2(&self) -> u64 {
        match self.x2_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x2_oneof::x2(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x2(&mut self) {
        self.x2_oneof = ::std::option::Option::None;
    }

    pub fn has_x2(&self) -> bool {
        match self.x2_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x2_oneof::x2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x2(&mut self, v: u64) {
        self.x2_oneof = ::std::option::Option::Some(ProcessorState_oneof_x2_oneof::x2(v))
    }

    // uint64 x3 = 3;


    pub fn get_x3(&self) -> u64 {
        match self.x3_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x3_oneof::x3(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x3(&mut self) {
        self.x3_oneof = ::std::option::Option::None;
    }

    pub fn has_x3(&self) -> bool {
        match self.x3_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x3_oneof::x3(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x3(&mut self, v: u64) {
        self.x3_oneof = ::std::option::Option::Some(ProcessorState_oneof_x3_oneof::x3(v))
    }

    // uint64 x4 = 4;


    pub fn get_x4(&self) -> u64 {
        match self.x4_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x4_oneof::x4(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x4(&mut self) {
        self.x4_oneof = ::std::option::Option::None;
    }

    pub fn has_x4(&self) -> bool {
        match self.x4_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x4_oneof::x4(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x4(&mut self, v: u64) {
        self.x4_oneof = ::std::option::Option::Some(ProcessorState_oneof_x4_oneof::x4(v))
    }

    // uint64 x5 = 5;


    pub fn get_x5(&self) -> u64 {
        match self.x5_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x5_oneof::x5(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x5(&mut self) {
        self.x5_oneof = ::std::option::Option::None;
    }

    pub fn has_x5(&self) -> bool {
        match self.x5_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x5_oneof::x5(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x5(&mut self, v: u64) {
        self.x5_oneof = ::std::option::Option::Some(ProcessorState_oneof_x5_oneof::x5(v))
    }

    // uint64 x6 = 6;


    pub fn get_x6(&self) -> u64 {
        match self.x6_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x6_oneof::x6(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x6(&mut self) {
        self.x6_oneof = ::std::option::Option::None;
    }

    pub fn has_x6(&self) -> bool {
        match self.x6_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x6_oneof::x6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x6(&mut self, v: u64) {
        self.x6_oneof = ::std::option::Option::Some(ProcessorState_oneof_x6_oneof::x6(v))
    }

    // uint64 x7 = 7;


    pub fn get_x7(&self) -> u64 {
        match self.x7_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x7_oneof::x7(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x7(&mut self) {
        self.x7_oneof = ::std::option::Option::None;
    }

    pub fn has_x7(&self) -> bool {
        match self.x7_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x7_oneof::x7(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x7(&mut self, v: u64) {
        self.x7_oneof = ::std::option::Option::Some(ProcessorState_oneof_x7_oneof::x7(v))
    }

    // uint64 x8 = 8;


    pub fn get_x8(&self) -> u64 {
        match self.x8_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x8_oneof::x8(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x8(&mut self) {
        self.x8_oneof = ::std::option::Option::None;
    }

    pub fn has_x8(&self) -> bool {
        match self.x8_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x8_oneof::x8(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x8(&mut self, v: u64) {
        self.x8_oneof = ::std::option::Option::Some(ProcessorState_oneof_x8_oneof::x8(v))
    }

    // uint64 x9 = 9;


    pub fn get_x9(&self) -> u64 {
        match self.x9_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x9_oneof::x9(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x9(&mut self) {
        self.x9_oneof = ::std::option::Option::None;
    }

    pub fn has_x9(&self) -> bool {
        match self.x9_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x9_oneof::x9(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x9(&mut self, v: u64) {
        self.x9_oneof = ::std::option::Option::Some(ProcessorState_oneof_x9_oneof::x9(v))
    }

    // uint64 x10 = 10;


    pub fn get_x10(&self) -> u64 {
        match self.x10_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x10_oneof::x10(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x10(&mut self) {
        self.x10_oneof = ::std::option::Option::None;
    }

    pub fn has_x10(&self) -> bool {
        match self.x10_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x10_oneof::x10(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x10(&mut self, v: u64) {
        self.x10_oneof = ::std::option::Option::Some(ProcessorState_oneof_x10_oneof::x10(v))
    }

    // uint64 x11 = 11;


    pub fn get_x11(&self) -> u64 {
        match self.x11_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x11_oneof::x11(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x11(&mut self) {
        self.x11_oneof = ::std::option::Option::None;
    }

    pub fn has_x11(&self) -> bool {
        match self.x11_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x11_oneof::x11(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x11(&mut self, v: u64) {
        self.x11_oneof = ::std::option::Option::Some(ProcessorState_oneof_x11_oneof::x11(v))
    }

    // uint64 x12 = 12;


    pub fn get_x12(&self) -> u64 {
        match self.x12_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x12_oneof::x12(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x12(&mut self) {
        self.x12_oneof = ::std::option::Option::None;
    }

    pub fn has_x12(&self) -> bool {
        match self.x12_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x12_oneof::x12(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x12(&mut self, v: u64) {
        self.x12_oneof = ::std::option::Option::Some(ProcessorState_oneof_x12_oneof::x12(v))
    }

    // uint64 x13 = 13;


    pub fn get_x13(&self) -> u64 {
        match self.x13_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x13_oneof::x13(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x13(&mut self) {
        self.x13_oneof = ::std::option::Option::None;
    }

    pub fn has_x13(&self) -> bool {
        match self.x13_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x13_oneof::x13(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x13(&mut self, v: u64) {
        self.x13_oneof = ::std::option::Option::Some(ProcessorState_oneof_x13_oneof::x13(v))
    }

    // uint64 x14 = 14;


    pub fn get_x14(&self) -> u64 {
        match self.x14_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x14_oneof::x14(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x14(&mut self) {
        self.x14_oneof = ::std::option::Option::None;
    }

    pub fn has_x14(&self) -> bool {
        match self.x14_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x14_oneof::x14(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x14(&mut self, v: u64) {
        self.x14_oneof = ::std::option::Option::Some(ProcessorState_oneof_x14_oneof::x14(v))
    }

    // uint64 x15 = 15;


    pub fn get_x15(&self) -> u64 {
        match self.x15_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x15_oneof::x15(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x15(&mut self) {
        self.x15_oneof = ::std::option::Option::None;
    }

    pub fn has_x15(&self) -> bool {
        match self.x15_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x15_oneof::x15(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x15(&mut self, v: u64) {
        self.x15_oneof = ::std::option::Option::Some(ProcessorState_oneof_x15_oneof::x15(v))
    }

    // uint64 x16 = 16;


    pub fn get_x16(&self) -> u64 {
        match self.x16_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x16_oneof::x16(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x16(&mut self) {
        self.x16_oneof = ::std::option::Option::None;
    }

    pub fn has_x16(&self) -> bool {
        match self.x16_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x16_oneof::x16(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x16(&mut self, v: u64) {
        self.x16_oneof = ::std::option::Option::Some(ProcessorState_oneof_x16_oneof::x16(v))
    }

    // uint64 x17 = 17;


    pub fn get_x17(&self) -> u64 {
        match self.x17_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x17_oneof::x17(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x17(&mut self) {
        self.x17_oneof = ::std::option::Option::None;
    }

    pub fn has_x17(&self) -> bool {
        match self.x17_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x17_oneof::x17(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x17(&mut self, v: u64) {
        self.x17_oneof = ::std::option::Option::Some(ProcessorState_oneof_x17_oneof::x17(v))
    }

    // uint64 x18 = 18;


    pub fn get_x18(&self) -> u64 {
        match self.x18_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x18_oneof::x18(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x18(&mut self) {
        self.x18_oneof = ::std::option::Option::None;
    }

    pub fn has_x18(&self) -> bool {
        match self.x18_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x18_oneof::x18(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x18(&mut self, v: u64) {
        self.x18_oneof = ::std::option::Option::Some(ProcessorState_oneof_x18_oneof::x18(v))
    }

    // uint64 x19 = 19;


    pub fn get_x19(&self) -> u64 {
        match self.x19_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x19_oneof::x19(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x19(&mut self) {
        self.x19_oneof = ::std::option::Option::None;
    }

    pub fn has_x19(&self) -> bool {
        match self.x19_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x19_oneof::x19(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x19(&mut self, v: u64) {
        self.x19_oneof = ::std::option::Option::Some(ProcessorState_oneof_x19_oneof::x19(v))
    }

    // uint64 x20 = 20;


    pub fn get_x20(&self) -> u64 {
        match self.x20_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x20_oneof::x20(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x20(&mut self) {
        self.x20_oneof = ::std::option::Option::None;
    }

    pub fn has_x20(&self) -> bool {
        match self.x20_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x20_oneof::x20(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x20(&mut self, v: u64) {
        self.x20_oneof = ::std::option::Option::Some(ProcessorState_oneof_x20_oneof::x20(v))
    }

    // uint64 x21 = 21;


    pub fn get_x21(&self) -> u64 {
        match self.x21_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x21_oneof::x21(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x21(&mut self) {
        self.x21_oneof = ::std::option::Option::None;
    }

    pub fn has_x21(&self) -> bool {
        match self.x21_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x21_oneof::x21(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x21(&mut self, v: u64) {
        self.x21_oneof = ::std::option::Option::Some(ProcessorState_oneof_x21_oneof::x21(v))
    }

    // uint64 x22 = 22;


    pub fn get_x22(&self) -> u64 {
        match self.x22_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x22_oneof::x22(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x22(&mut self) {
        self.x22_oneof = ::std::option::Option::None;
    }

    pub fn has_x22(&self) -> bool {
        match self.x22_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x22_oneof::x22(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x22(&mut self, v: u64) {
        self.x22_oneof = ::std::option::Option::Some(ProcessorState_oneof_x22_oneof::x22(v))
    }

    // uint64 x23 = 23;


    pub fn get_x23(&self) -> u64 {
        match self.x23_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x23_oneof::x23(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x23(&mut self) {
        self.x23_oneof = ::std::option::Option::None;
    }

    pub fn has_x23(&self) -> bool {
        match self.x23_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x23_oneof::x23(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x23(&mut self, v: u64) {
        self.x23_oneof = ::std::option::Option::Some(ProcessorState_oneof_x23_oneof::x23(v))
    }

    // uint64 x24 = 24;


    pub fn get_x24(&self) -> u64 {
        match self.x24_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x24_oneof::x24(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x24(&mut self) {
        self.x24_oneof = ::std::option::Option::None;
    }

    pub fn has_x24(&self) -> bool {
        match self.x24_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x24_oneof::x24(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x24(&mut self, v: u64) {
        self.x24_oneof = ::std::option::Option::Some(ProcessorState_oneof_x24_oneof::x24(v))
    }

    // uint64 x25 = 25;


    pub fn get_x25(&self) -> u64 {
        match self.x25_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x25_oneof::x25(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x25(&mut self) {
        self.x25_oneof = ::std::option::Option::None;
    }

    pub fn has_x25(&self) -> bool {
        match self.x25_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x25_oneof::x25(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x25(&mut self, v: u64) {
        self.x25_oneof = ::std::option::Option::Some(ProcessorState_oneof_x25_oneof::x25(v))
    }

    // uint64 x26 = 26;


    pub fn get_x26(&self) -> u64 {
        match self.x26_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x26_oneof::x26(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x26(&mut self) {
        self.x26_oneof = ::std::option::Option::None;
    }

    pub fn has_x26(&self) -> bool {
        match self.x26_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x26_oneof::x26(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x26(&mut self, v: u64) {
        self.x26_oneof = ::std::option::Option::Some(ProcessorState_oneof_x26_oneof::x26(v))
    }

    // uint64 x27 = 27;


    pub fn get_x27(&self) -> u64 {
        match self.x27_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x27_oneof::x27(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x27(&mut self) {
        self.x27_oneof = ::std::option::Option::None;
    }

    pub fn has_x27(&self) -> bool {
        match self.x27_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x27_oneof::x27(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x27(&mut self, v: u64) {
        self.x27_oneof = ::std::option::Option::Some(ProcessorState_oneof_x27_oneof::x27(v))
    }

    // uint64 x28 = 28;


    pub fn get_x28(&self) -> u64 {
        match self.x28_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x28_oneof::x28(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x28(&mut self) {
        self.x28_oneof = ::std::option::Option::None;
    }

    pub fn has_x28(&self) -> bool {
        match self.x28_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x28_oneof::x28(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x28(&mut self, v: u64) {
        self.x28_oneof = ::std::option::Option::Some(ProcessorState_oneof_x28_oneof::x28(v))
    }

    // uint64 x29 = 29;


    pub fn get_x29(&self) -> u64 {
        match self.x29_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x29_oneof::x29(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x29(&mut self) {
        self.x29_oneof = ::std::option::Option::None;
    }

    pub fn has_x29(&self) -> bool {
        match self.x29_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x29_oneof::x29(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x29(&mut self, v: u64) {
        self.x29_oneof = ::std::option::Option::Some(ProcessorState_oneof_x29_oneof::x29(v))
    }

    // uint64 x30 = 30;


    pub fn get_x30(&self) -> u64 {
        match self.x30_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x30_oneof::x30(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x30(&mut self) {
        self.x30_oneof = ::std::option::Option::None;
    }

    pub fn has_x30(&self) -> bool {
        match self.x30_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x30_oneof::x30(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x30(&mut self, v: u64) {
        self.x30_oneof = ::std::option::Option::Some(ProcessorState_oneof_x30_oneof::x30(v))
    }

    // uint64 x31 = 31;


    pub fn get_x31(&self) -> u64 {
        match self.x31_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x31_oneof::x31(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_x31(&mut self) {
        self.x31_oneof = ::std::option::Option::None;
    }

    pub fn has_x31(&self) -> bool {
        match self.x31_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_x31_oneof::x31(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x31(&mut self, v: u64) {
        self.x31_oneof = ::std::option::Option::Some(ProcessorState_oneof_x31_oneof::x31(v))
    }

    // uint64 pc = 32;


    pub fn get_pc(&self) -> u64 {
        match self.pc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_pc_oneof::pc(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_pc(&mut self) {
        self.pc_oneof = ::std::option::Option::None;
    }

    pub fn has_pc(&self) -> bool {
        match self.pc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_pc_oneof::pc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pc(&mut self, v: u64) {
        self.pc_oneof = ::std::option::Option::Some(ProcessorState_oneof_pc_oneof::pc(v))
    }

    // uint64 mvendorid = 33;


    pub fn get_mvendorid(&self) -> u64 {
        match self.mvendorid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mvendorid_oneof::mvendorid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mvendorid(&mut self) {
        self.mvendorid_oneof = ::std::option::Option::None;
    }

    pub fn has_mvendorid(&self) -> bool {
        match self.mvendorid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mvendorid_oneof::mvendorid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mvendorid(&mut self, v: u64) {
        self.mvendorid_oneof = ::std::option::Option::Some(ProcessorState_oneof_mvendorid_oneof::mvendorid(v))
    }

    // uint64 marchid = 34;


    pub fn get_marchid(&self) -> u64 {
        match self.marchid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_marchid_oneof::marchid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_marchid(&mut self) {
        self.marchid_oneof = ::std::option::Option::None;
    }

    pub fn has_marchid(&self) -> bool {
        match self.marchid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_marchid_oneof::marchid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_marchid(&mut self, v: u64) {
        self.marchid_oneof = ::std::option::Option::Some(ProcessorState_oneof_marchid_oneof::marchid(v))
    }

    // uint64 mimpid = 35;


    pub fn get_mimpid(&self) -> u64 {
        match self.mimpid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mimpid_oneof::mimpid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mimpid(&mut self) {
        self.mimpid_oneof = ::std::option::Option::None;
    }

    pub fn has_mimpid(&self) -> bool {
        match self.mimpid_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mimpid_oneof::mimpid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mimpid(&mut self, v: u64) {
        self.mimpid_oneof = ::std::option::Option::Some(ProcessorState_oneof_mimpid_oneof::mimpid(v))
    }

    // uint64 mcycle = 36;


    pub fn get_mcycle(&self) -> u64 {
        match self.mcycle_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcycle_oneof::mcycle(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mcycle(&mut self) {
        self.mcycle_oneof = ::std::option::Option::None;
    }

    pub fn has_mcycle(&self) -> bool {
        match self.mcycle_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcycle_oneof::mcycle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mcycle(&mut self, v: u64) {
        self.mcycle_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcycle_oneof::mcycle(v))
    }

    // uint64 minstret = 37;


    pub fn get_minstret(&self) -> u64 {
        match self.minstret_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_minstret_oneof::minstret(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_minstret(&mut self) {
        self.minstret_oneof = ::std::option::Option::None;
    }

    pub fn has_minstret(&self) -> bool {
        match self.minstret_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_minstret_oneof::minstret(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_minstret(&mut self, v: u64) {
        self.minstret_oneof = ::std::option::Option::Some(ProcessorState_oneof_minstret_oneof::minstret(v))
    }

    // uint64 mstatus = 38;


    pub fn get_mstatus(&self) -> u64 {
        match self.mstatus_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mstatus_oneof::mstatus(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mstatus(&mut self) {
        self.mstatus_oneof = ::std::option::Option::None;
    }

    pub fn has_mstatus(&self) -> bool {
        match self.mstatus_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mstatus_oneof::mstatus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mstatus(&mut self, v: u64) {
        self.mstatus_oneof = ::std::option::Option::Some(ProcessorState_oneof_mstatus_oneof::mstatus(v))
    }

    // uint64 mtvec = 39;


    pub fn get_mtvec(&self) -> u64 {
        match self.mtvec_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mtvec_oneof::mtvec(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mtvec(&mut self) {
        self.mtvec_oneof = ::std::option::Option::None;
    }

    pub fn has_mtvec(&self) -> bool {
        match self.mtvec_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mtvec_oneof::mtvec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mtvec(&mut self, v: u64) {
        self.mtvec_oneof = ::std::option::Option::Some(ProcessorState_oneof_mtvec_oneof::mtvec(v))
    }

    // uint64 mscratch = 40;


    pub fn get_mscratch(&self) -> u64 {
        match self.mscratch_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mscratch_oneof::mscratch(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mscratch(&mut self) {
        self.mscratch_oneof = ::std::option::Option::None;
    }

    pub fn has_mscratch(&self) -> bool {
        match self.mscratch_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mscratch_oneof::mscratch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mscratch(&mut self, v: u64) {
        self.mscratch_oneof = ::std::option::Option::Some(ProcessorState_oneof_mscratch_oneof::mscratch(v))
    }

    // uint64 mepc = 41;


    pub fn get_mepc(&self) -> u64 {
        match self.mepc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mepc_oneof::mepc(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mepc(&mut self) {
        self.mepc_oneof = ::std::option::Option::None;
    }

    pub fn has_mepc(&self) -> bool {
        match self.mepc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mepc_oneof::mepc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mepc(&mut self, v: u64) {
        self.mepc_oneof = ::std::option::Option::Some(ProcessorState_oneof_mepc_oneof::mepc(v))
    }

    // uint64 mcause = 42;


    pub fn get_mcause(&self) -> u64 {
        match self.mcause_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcause_oneof::mcause(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mcause(&mut self) {
        self.mcause_oneof = ::std::option::Option::None;
    }

    pub fn has_mcause(&self) -> bool {
        match self.mcause_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcause_oneof::mcause(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mcause(&mut self, v: u64) {
        self.mcause_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcause_oneof::mcause(v))
    }

    // uint64 mtval = 43;


    pub fn get_mtval(&self) -> u64 {
        match self.mtval_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mtval_oneof::mtval(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mtval(&mut self) {
        self.mtval_oneof = ::std::option::Option::None;
    }

    pub fn has_mtval(&self) -> bool {
        match self.mtval_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mtval_oneof::mtval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mtval(&mut self, v: u64) {
        self.mtval_oneof = ::std::option::Option::Some(ProcessorState_oneof_mtval_oneof::mtval(v))
    }

    // uint64 misa = 44;


    pub fn get_misa(&self) -> u64 {
        match self.misa_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_misa_oneof::misa(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_misa(&mut self) {
        self.misa_oneof = ::std::option::Option::None;
    }

    pub fn has_misa(&self) -> bool {
        match self.misa_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_misa_oneof::misa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_misa(&mut self, v: u64) {
        self.misa_oneof = ::std::option::Option::Some(ProcessorState_oneof_misa_oneof::misa(v))
    }

    // uint64 mie = 45;


    pub fn get_mie(&self) -> u64 {
        match self.mie_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mie_oneof::mie(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mie(&mut self) {
        self.mie_oneof = ::std::option::Option::None;
    }

    pub fn has_mie(&self) -> bool {
        match self.mie_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mie_oneof::mie(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mie(&mut self, v: u64) {
        self.mie_oneof = ::std::option::Option::Some(ProcessorState_oneof_mie_oneof::mie(v))
    }

    // uint64 mip = 46;


    pub fn get_mip(&self) -> u64 {
        match self.mip_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mip_oneof::mip(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mip(&mut self) {
        self.mip_oneof = ::std::option::Option::None;
    }

    pub fn has_mip(&self) -> bool {
        match self.mip_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mip_oneof::mip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mip(&mut self, v: u64) {
        self.mip_oneof = ::std::option::Option::Some(ProcessorState_oneof_mip_oneof::mip(v))
    }

    // uint64 medeleg = 47;


    pub fn get_medeleg(&self) -> u64 {
        match self.medeleg_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_medeleg_oneof::medeleg(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_medeleg(&mut self) {
        self.medeleg_oneof = ::std::option::Option::None;
    }

    pub fn has_medeleg(&self) -> bool {
        match self.medeleg_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_medeleg_oneof::medeleg(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medeleg(&mut self, v: u64) {
        self.medeleg_oneof = ::std::option::Option::Some(ProcessorState_oneof_medeleg_oneof::medeleg(v))
    }

    // uint64 mideleg = 48;


    pub fn get_mideleg(&self) -> u64 {
        match self.mideleg_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mideleg_oneof::mideleg(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mideleg(&mut self) {
        self.mideleg_oneof = ::std::option::Option::None;
    }

    pub fn has_mideleg(&self) -> bool {
        match self.mideleg_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mideleg_oneof::mideleg(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mideleg(&mut self, v: u64) {
        self.mideleg_oneof = ::std::option::Option::Some(ProcessorState_oneof_mideleg_oneof::mideleg(v))
    }

    // uint64 mcounteren = 49;


    pub fn get_mcounteren(&self) -> u64 {
        match self.mcounteren_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcounteren_oneof::mcounteren(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mcounteren(&mut self) {
        self.mcounteren_oneof = ::std::option::Option::None;
    }

    pub fn has_mcounteren(&self) -> bool {
        match self.mcounteren_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_mcounteren_oneof::mcounteren(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mcounteren(&mut self, v: u64) {
        self.mcounteren_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcounteren_oneof::mcounteren(v))
    }

    // uint64 stvec = 50;


    pub fn get_stvec(&self) -> u64 {
        match self.stvec_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_stvec_oneof::stvec(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_stvec(&mut self) {
        self.stvec_oneof = ::std::option::Option::None;
    }

    pub fn has_stvec(&self) -> bool {
        match self.stvec_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_stvec_oneof::stvec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stvec(&mut self, v: u64) {
        self.stvec_oneof = ::std::option::Option::Some(ProcessorState_oneof_stvec_oneof::stvec(v))
    }

    // uint64 sscratch = 51;


    pub fn get_sscratch(&self) -> u64 {
        match self.sscratch_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_sscratch_oneof::sscratch(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sscratch(&mut self) {
        self.sscratch_oneof = ::std::option::Option::None;
    }

    pub fn has_sscratch(&self) -> bool {
        match self.sscratch_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_sscratch_oneof::sscratch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sscratch(&mut self, v: u64) {
        self.sscratch_oneof = ::std::option::Option::Some(ProcessorState_oneof_sscratch_oneof::sscratch(v))
    }

    // uint64 sepc = 52;


    pub fn get_sepc(&self) -> u64 {
        match self.sepc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_sepc_oneof::sepc(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sepc(&mut self) {
        self.sepc_oneof = ::std::option::Option::None;
    }

    pub fn has_sepc(&self) -> bool {
        match self.sepc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_sepc_oneof::sepc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sepc(&mut self, v: u64) {
        self.sepc_oneof = ::std::option::Option::Some(ProcessorState_oneof_sepc_oneof::sepc(v))
    }

    // uint64 scause = 53;


    pub fn get_scause(&self) -> u64 {
        match self.scause_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_scause_oneof::scause(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_scause(&mut self) {
        self.scause_oneof = ::std::option::Option::None;
    }

    pub fn has_scause(&self) -> bool {
        match self.scause_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_scause_oneof::scause(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scause(&mut self, v: u64) {
        self.scause_oneof = ::std::option::Option::Some(ProcessorState_oneof_scause_oneof::scause(v))
    }

    // uint64 stval = 54;


    pub fn get_stval(&self) -> u64 {
        match self.stval_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_stval_oneof::stval(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_stval(&mut self) {
        self.stval_oneof = ::std::option::Option::None;
    }

    pub fn has_stval(&self) -> bool {
        match self.stval_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_stval_oneof::stval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stval(&mut self, v: u64) {
        self.stval_oneof = ::std::option::Option::Some(ProcessorState_oneof_stval_oneof::stval(v))
    }

    // uint64 satp = 55;


    pub fn get_satp(&self) -> u64 {
        match self.satp_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_satp_oneof::satp(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_satp(&mut self) {
        self.satp_oneof = ::std::option::Option::None;
    }

    pub fn has_satp(&self) -> bool {
        match self.satp_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_satp_oneof::satp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_satp(&mut self, v: u64) {
        self.satp_oneof = ::std::option::Option::Some(ProcessorState_oneof_satp_oneof::satp(v))
    }

    // uint64 scounteren = 56;


    pub fn get_scounteren(&self) -> u64 {
        match self.scounteren_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_scounteren_oneof::scounteren(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_scounteren(&mut self) {
        self.scounteren_oneof = ::std::option::Option::None;
    }

    pub fn has_scounteren(&self) -> bool {
        match self.scounteren_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_scounteren_oneof::scounteren(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scounteren(&mut self, v: u64) {
        self.scounteren_oneof = ::std::option::Option::Some(ProcessorState_oneof_scounteren_oneof::scounteren(v))
    }

    // uint64 ilrsc = 57;


    pub fn get_ilrsc(&self) -> u64 {
        match self.ilrsc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_ilrsc_oneof::ilrsc(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_ilrsc(&mut self) {
        self.ilrsc_oneof = ::std::option::Option::None;
    }

    pub fn has_ilrsc(&self) -> bool {
        match self.ilrsc_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_ilrsc_oneof::ilrsc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ilrsc(&mut self, v: u64) {
        self.ilrsc_oneof = ::std::option::Option::Some(ProcessorState_oneof_ilrsc_oneof::ilrsc(v))
    }

    // uint64 iflags = 58;


    pub fn get_iflags(&self) -> u64 {
        match self.iflags_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_iflags_oneof::iflags(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_iflags(&mut self) {
        self.iflags_oneof = ::std::option::Option::None;
    }

    pub fn has_iflags(&self) -> bool {
        match self.iflags_oneof {
            ::std::option::Option::Some(ProcessorState_oneof_iflags_oneof::iflags(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_iflags(&mut self, v: u64) {
        self.iflags_oneof = ::std::option::Option::Some(ProcessorState_oneof_iflags_oneof::iflags(v))
    }
}

impl ::protobuf::Message for ProcessorState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x1_oneof = ::std::option::Option::Some(ProcessorState_oneof_x1_oneof::x1(is.read_uint64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x2_oneof = ::std::option::Option::Some(ProcessorState_oneof_x2_oneof::x2(is.read_uint64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x3_oneof = ::std::option::Option::Some(ProcessorState_oneof_x3_oneof::x3(is.read_uint64()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x4_oneof = ::std::option::Option::Some(ProcessorState_oneof_x4_oneof::x4(is.read_uint64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x5_oneof = ::std::option::Option::Some(ProcessorState_oneof_x5_oneof::x5(is.read_uint64()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x6_oneof = ::std::option::Option::Some(ProcessorState_oneof_x6_oneof::x6(is.read_uint64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x7_oneof = ::std::option::Option::Some(ProcessorState_oneof_x7_oneof::x7(is.read_uint64()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x8_oneof = ::std::option::Option::Some(ProcessorState_oneof_x8_oneof::x8(is.read_uint64()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x9_oneof = ::std::option::Option::Some(ProcessorState_oneof_x9_oneof::x9(is.read_uint64()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x10_oneof = ::std::option::Option::Some(ProcessorState_oneof_x10_oneof::x10(is.read_uint64()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x11_oneof = ::std::option::Option::Some(ProcessorState_oneof_x11_oneof::x11(is.read_uint64()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x12_oneof = ::std::option::Option::Some(ProcessorState_oneof_x12_oneof::x12(is.read_uint64()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x13_oneof = ::std::option::Option::Some(ProcessorState_oneof_x13_oneof::x13(is.read_uint64()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x14_oneof = ::std::option::Option::Some(ProcessorState_oneof_x14_oneof::x14(is.read_uint64()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x15_oneof = ::std::option::Option::Some(ProcessorState_oneof_x15_oneof::x15(is.read_uint64()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x16_oneof = ::std::option::Option::Some(ProcessorState_oneof_x16_oneof::x16(is.read_uint64()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x17_oneof = ::std::option::Option::Some(ProcessorState_oneof_x17_oneof::x17(is.read_uint64()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x18_oneof = ::std::option::Option::Some(ProcessorState_oneof_x18_oneof::x18(is.read_uint64()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x19_oneof = ::std::option::Option::Some(ProcessorState_oneof_x19_oneof::x19(is.read_uint64()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x20_oneof = ::std::option::Option::Some(ProcessorState_oneof_x20_oneof::x20(is.read_uint64()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x21_oneof = ::std::option::Option::Some(ProcessorState_oneof_x21_oneof::x21(is.read_uint64()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x22_oneof = ::std::option::Option::Some(ProcessorState_oneof_x22_oneof::x22(is.read_uint64()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x23_oneof = ::std::option::Option::Some(ProcessorState_oneof_x23_oneof::x23(is.read_uint64()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x24_oneof = ::std::option::Option::Some(ProcessorState_oneof_x24_oneof::x24(is.read_uint64()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x25_oneof = ::std::option::Option::Some(ProcessorState_oneof_x25_oneof::x25(is.read_uint64()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x26_oneof = ::std::option::Option::Some(ProcessorState_oneof_x26_oneof::x26(is.read_uint64()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x27_oneof = ::std::option::Option::Some(ProcessorState_oneof_x27_oneof::x27(is.read_uint64()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x28_oneof = ::std::option::Option::Some(ProcessorState_oneof_x28_oneof::x28(is.read_uint64()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x29_oneof = ::std::option::Option::Some(ProcessorState_oneof_x29_oneof::x29(is.read_uint64()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x30_oneof = ::std::option::Option::Some(ProcessorState_oneof_x30_oneof::x30(is.read_uint64()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x31_oneof = ::std::option::Option::Some(ProcessorState_oneof_x31_oneof::x31(is.read_uint64()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pc_oneof = ::std::option::Option::Some(ProcessorState_oneof_pc_oneof::pc(is.read_uint64()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mvendorid_oneof = ::std::option::Option::Some(ProcessorState_oneof_mvendorid_oneof::mvendorid(is.read_uint64()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.marchid_oneof = ::std::option::Option::Some(ProcessorState_oneof_marchid_oneof::marchid(is.read_uint64()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mimpid_oneof = ::std::option::Option::Some(ProcessorState_oneof_mimpid_oneof::mimpid(is.read_uint64()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mcycle_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcycle_oneof::mcycle(is.read_uint64()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.minstret_oneof = ::std::option::Option::Some(ProcessorState_oneof_minstret_oneof::minstret(is.read_uint64()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mstatus_oneof = ::std::option::Option::Some(ProcessorState_oneof_mstatus_oneof::mstatus(is.read_uint64()?));
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mtvec_oneof = ::std::option::Option::Some(ProcessorState_oneof_mtvec_oneof::mtvec(is.read_uint64()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mscratch_oneof = ::std::option::Option::Some(ProcessorState_oneof_mscratch_oneof::mscratch(is.read_uint64()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mepc_oneof = ::std::option::Option::Some(ProcessorState_oneof_mepc_oneof::mepc(is.read_uint64()?));
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mcause_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcause_oneof::mcause(is.read_uint64()?));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mtval_oneof = ::std::option::Option::Some(ProcessorState_oneof_mtval_oneof::mtval(is.read_uint64()?));
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.misa_oneof = ::std::option::Option::Some(ProcessorState_oneof_misa_oneof::misa(is.read_uint64()?));
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mie_oneof = ::std::option::Option::Some(ProcessorState_oneof_mie_oneof::mie(is.read_uint64()?));
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mip_oneof = ::std::option::Option::Some(ProcessorState_oneof_mip_oneof::mip(is.read_uint64()?));
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.medeleg_oneof = ::std::option::Option::Some(ProcessorState_oneof_medeleg_oneof::medeleg(is.read_uint64()?));
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mideleg_oneof = ::std::option::Option::Some(ProcessorState_oneof_mideleg_oneof::mideleg(is.read_uint64()?));
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mcounteren_oneof = ::std::option::Option::Some(ProcessorState_oneof_mcounteren_oneof::mcounteren(is.read_uint64()?));
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stvec_oneof = ::std::option::Option::Some(ProcessorState_oneof_stvec_oneof::stvec(is.read_uint64()?));
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sscratch_oneof = ::std::option::Option::Some(ProcessorState_oneof_sscratch_oneof::sscratch(is.read_uint64()?));
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sepc_oneof = ::std::option::Option::Some(ProcessorState_oneof_sepc_oneof::sepc(is.read_uint64()?));
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scause_oneof = ::std::option::Option::Some(ProcessorState_oneof_scause_oneof::scause(is.read_uint64()?));
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stval_oneof = ::std::option::Option::Some(ProcessorState_oneof_stval_oneof::stval(is.read_uint64()?));
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.satp_oneof = ::std::option::Option::Some(ProcessorState_oneof_satp_oneof::satp(is.read_uint64()?));
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scounteren_oneof = ::std::option::Option::Some(ProcessorState_oneof_scounteren_oneof::scounteren(is.read_uint64()?));
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ilrsc_oneof = ::std::option::Option::Some(ProcessorState_oneof_ilrsc_oneof::ilrsc(is.read_uint64()?));
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.iflags_oneof = ::std::option::Option::Some(ProcessorState_oneof_iflags_oneof::iflags(is.read_uint64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.x1_oneof {
            match v {
                &ProcessorState_oneof_x1_oneof::x1(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x2_oneof {
            match v {
                &ProcessorState_oneof_x2_oneof::x2(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x3_oneof {
            match v {
                &ProcessorState_oneof_x3_oneof::x3(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x4_oneof {
            match v {
                &ProcessorState_oneof_x4_oneof::x4(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x5_oneof {
            match v {
                &ProcessorState_oneof_x5_oneof::x5(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x6_oneof {
            match v {
                &ProcessorState_oneof_x6_oneof::x6(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x7_oneof {
            match v {
                &ProcessorState_oneof_x7_oneof::x7(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x8_oneof {
            match v {
                &ProcessorState_oneof_x8_oneof::x8(v) => {
                    my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x9_oneof {
            match v {
                &ProcessorState_oneof_x9_oneof::x9(v) => {
                    my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x10_oneof {
            match v {
                &ProcessorState_oneof_x10_oneof::x10(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x11_oneof {
            match v {
                &ProcessorState_oneof_x11_oneof::x11(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x12_oneof {
            match v {
                &ProcessorState_oneof_x12_oneof::x12(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x13_oneof {
            match v {
                &ProcessorState_oneof_x13_oneof::x13(v) => {
                    my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x14_oneof {
            match v {
                &ProcessorState_oneof_x14_oneof::x14(v) => {
                    my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x15_oneof {
            match v {
                &ProcessorState_oneof_x15_oneof::x15(v) => {
                    my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x16_oneof {
            match v {
                &ProcessorState_oneof_x16_oneof::x16(v) => {
                    my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x17_oneof {
            match v {
                &ProcessorState_oneof_x17_oneof::x17(v) => {
                    my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x18_oneof {
            match v {
                &ProcessorState_oneof_x18_oneof::x18(v) => {
                    my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x19_oneof {
            match v {
                &ProcessorState_oneof_x19_oneof::x19(v) => {
                    my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x20_oneof {
            match v {
                &ProcessorState_oneof_x20_oneof::x20(v) => {
                    my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x21_oneof {
            match v {
                &ProcessorState_oneof_x21_oneof::x21(v) => {
                    my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x22_oneof {
            match v {
                &ProcessorState_oneof_x22_oneof::x22(v) => {
                    my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x23_oneof {
            match v {
                &ProcessorState_oneof_x23_oneof::x23(v) => {
                    my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x24_oneof {
            match v {
                &ProcessorState_oneof_x24_oneof::x24(v) => {
                    my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x25_oneof {
            match v {
                &ProcessorState_oneof_x25_oneof::x25(v) => {
                    my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x26_oneof {
            match v {
                &ProcessorState_oneof_x26_oneof::x26(v) => {
                    my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x27_oneof {
            match v {
                &ProcessorState_oneof_x27_oneof::x27(v) => {
                    my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x28_oneof {
            match v {
                &ProcessorState_oneof_x28_oneof::x28(v) => {
                    my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x29_oneof {
            match v {
                &ProcessorState_oneof_x29_oneof::x29(v) => {
                    my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x30_oneof {
            match v {
                &ProcessorState_oneof_x30_oneof::x30(v) => {
                    my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x31_oneof {
            match v {
                &ProcessorState_oneof_x31_oneof::x31(v) => {
                    my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.pc_oneof {
            match v {
                &ProcessorState_oneof_pc_oneof::pc(v) => {
                    my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mvendorid_oneof {
            match v {
                &ProcessorState_oneof_mvendorid_oneof::mvendorid(v) => {
                    my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.marchid_oneof {
            match v {
                &ProcessorState_oneof_marchid_oneof::marchid(v) => {
                    my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mimpid_oneof {
            match v {
                &ProcessorState_oneof_mimpid_oneof::mimpid(v) => {
                    my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcycle_oneof {
            match v {
                &ProcessorState_oneof_mcycle_oneof::mcycle(v) => {
                    my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.minstret_oneof {
            match v {
                &ProcessorState_oneof_minstret_oneof::minstret(v) => {
                    my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mstatus_oneof {
            match v {
                &ProcessorState_oneof_mstatus_oneof::mstatus(v) => {
                    my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mtvec_oneof {
            match v {
                &ProcessorState_oneof_mtvec_oneof::mtvec(v) => {
                    my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mscratch_oneof {
            match v {
                &ProcessorState_oneof_mscratch_oneof::mscratch(v) => {
                    my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mepc_oneof {
            match v {
                &ProcessorState_oneof_mepc_oneof::mepc(v) => {
                    my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcause_oneof {
            match v {
                &ProcessorState_oneof_mcause_oneof::mcause(v) => {
                    my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mtval_oneof {
            match v {
                &ProcessorState_oneof_mtval_oneof::mtval(v) => {
                    my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.misa_oneof {
            match v {
                &ProcessorState_oneof_misa_oneof::misa(v) => {
                    my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mie_oneof {
            match v {
                &ProcessorState_oneof_mie_oneof::mie(v) => {
                    my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mip_oneof {
            match v {
                &ProcessorState_oneof_mip_oneof::mip(v) => {
                    my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.medeleg_oneof {
            match v {
                &ProcessorState_oneof_medeleg_oneof::medeleg(v) => {
                    my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mideleg_oneof {
            match v {
                &ProcessorState_oneof_mideleg_oneof::mideleg(v) => {
                    my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcounteren_oneof {
            match v {
                &ProcessorState_oneof_mcounteren_oneof::mcounteren(v) => {
                    my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.stvec_oneof {
            match v {
                &ProcessorState_oneof_stvec_oneof::stvec(v) => {
                    my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.sscratch_oneof {
            match v {
                &ProcessorState_oneof_sscratch_oneof::sscratch(v) => {
                    my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.sepc_oneof {
            match v {
                &ProcessorState_oneof_sepc_oneof::sepc(v) => {
                    my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.scause_oneof {
            match v {
                &ProcessorState_oneof_scause_oneof::scause(v) => {
                    my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.stval_oneof {
            match v {
                &ProcessorState_oneof_stval_oneof::stval(v) => {
                    my_size += ::protobuf::rt::value_size(54, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.satp_oneof {
            match v {
                &ProcessorState_oneof_satp_oneof::satp(v) => {
                    my_size += ::protobuf::rt::value_size(55, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.scounteren_oneof {
            match v {
                &ProcessorState_oneof_scounteren_oneof::scounteren(v) => {
                    my_size += ::protobuf::rt::value_size(56, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.ilrsc_oneof {
            match v {
                &ProcessorState_oneof_ilrsc_oneof::ilrsc(v) => {
                    my_size += ::protobuf::rt::value_size(57, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.iflags_oneof {
            match v {
                &ProcessorState_oneof_iflags_oneof::iflags(v) => {
                    my_size += ::protobuf::rt::value_size(58, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.x1_oneof {
            match v {
                &ProcessorState_oneof_x1_oneof::x1(v) => {
                    os.write_uint64(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x2_oneof {
            match v {
                &ProcessorState_oneof_x2_oneof::x2(v) => {
                    os.write_uint64(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x3_oneof {
            match v {
                &ProcessorState_oneof_x3_oneof::x3(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x4_oneof {
            match v {
                &ProcessorState_oneof_x4_oneof::x4(v) => {
                    os.write_uint64(4, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x5_oneof {
            match v {
                &ProcessorState_oneof_x5_oneof::x5(v) => {
                    os.write_uint64(5, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x6_oneof {
            match v {
                &ProcessorState_oneof_x6_oneof::x6(v) => {
                    os.write_uint64(6, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x7_oneof {
            match v {
                &ProcessorState_oneof_x7_oneof::x7(v) => {
                    os.write_uint64(7, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x8_oneof {
            match v {
                &ProcessorState_oneof_x8_oneof::x8(v) => {
                    os.write_uint64(8, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x9_oneof {
            match v {
                &ProcessorState_oneof_x9_oneof::x9(v) => {
                    os.write_uint64(9, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x10_oneof {
            match v {
                &ProcessorState_oneof_x10_oneof::x10(v) => {
                    os.write_uint64(10, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x11_oneof {
            match v {
                &ProcessorState_oneof_x11_oneof::x11(v) => {
                    os.write_uint64(11, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x12_oneof {
            match v {
                &ProcessorState_oneof_x12_oneof::x12(v) => {
                    os.write_uint64(12, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x13_oneof {
            match v {
                &ProcessorState_oneof_x13_oneof::x13(v) => {
                    os.write_uint64(13, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x14_oneof {
            match v {
                &ProcessorState_oneof_x14_oneof::x14(v) => {
                    os.write_uint64(14, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x15_oneof {
            match v {
                &ProcessorState_oneof_x15_oneof::x15(v) => {
                    os.write_uint64(15, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x16_oneof {
            match v {
                &ProcessorState_oneof_x16_oneof::x16(v) => {
                    os.write_uint64(16, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x17_oneof {
            match v {
                &ProcessorState_oneof_x17_oneof::x17(v) => {
                    os.write_uint64(17, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x18_oneof {
            match v {
                &ProcessorState_oneof_x18_oneof::x18(v) => {
                    os.write_uint64(18, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x19_oneof {
            match v {
                &ProcessorState_oneof_x19_oneof::x19(v) => {
                    os.write_uint64(19, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x20_oneof {
            match v {
                &ProcessorState_oneof_x20_oneof::x20(v) => {
                    os.write_uint64(20, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x21_oneof {
            match v {
                &ProcessorState_oneof_x21_oneof::x21(v) => {
                    os.write_uint64(21, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x22_oneof {
            match v {
                &ProcessorState_oneof_x22_oneof::x22(v) => {
                    os.write_uint64(22, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x23_oneof {
            match v {
                &ProcessorState_oneof_x23_oneof::x23(v) => {
                    os.write_uint64(23, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x24_oneof {
            match v {
                &ProcessorState_oneof_x24_oneof::x24(v) => {
                    os.write_uint64(24, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x25_oneof {
            match v {
                &ProcessorState_oneof_x25_oneof::x25(v) => {
                    os.write_uint64(25, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x26_oneof {
            match v {
                &ProcessorState_oneof_x26_oneof::x26(v) => {
                    os.write_uint64(26, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x27_oneof {
            match v {
                &ProcessorState_oneof_x27_oneof::x27(v) => {
                    os.write_uint64(27, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x28_oneof {
            match v {
                &ProcessorState_oneof_x28_oneof::x28(v) => {
                    os.write_uint64(28, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x29_oneof {
            match v {
                &ProcessorState_oneof_x29_oneof::x29(v) => {
                    os.write_uint64(29, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x30_oneof {
            match v {
                &ProcessorState_oneof_x30_oneof::x30(v) => {
                    os.write_uint64(30, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.x31_oneof {
            match v {
                &ProcessorState_oneof_x31_oneof::x31(v) => {
                    os.write_uint64(31, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.pc_oneof {
            match v {
                &ProcessorState_oneof_pc_oneof::pc(v) => {
                    os.write_uint64(32, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mvendorid_oneof {
            match v {
                &ProcessorState_oneof_mvendorid_oneof::mvendorid(v) => {
                    os.write_uint64(33, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.marchid_oneof {
            match v {
                &ProcessorState_oneof_marchid_oneof::marchid(v) => {
                    os.write_uint64(34, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mimpid_oneof {
            match v {
                &ProcessorState_oneof_mimpid_oneof::mimpid(v) => {
                    os.write_uint64(35, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcycle_oneof {
            match v {
                &ProcessorState_oneof_mcycle_oneof::mcycle(v) => {
                    os.write_uint64(36, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.minstret_oneof {
            match v {
                &ProcessorState_oneof_minstret_oneof::minstret(v) => {
                    os.write_uint64(37, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mstatus_oneof {
            match v {
                &ProcessorState_oneof_mstatus_oneof::mstatus(v) => {
                    os.write_uint64(38, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mtvec_oneof {
            match v {
                &ProcessorState_oneof_mtvec_oneof::mtvec(v) => {
                    os.write_uint64(39, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mscratch_oneof {
            match v {
                &ProcessorState_oneof_mscratch_oneof::mscratch(v) => {
                    os.write_uint64(40, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mepc_oneof {
            match v {
                &ProcessorState_oneof_mepc_oneof::mepc(v) => {
                    os.write_uint64(41, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcause_oneof {
            match v {
                &ProcessorState_oneof_mcause_oneof::mcause(v) => {
                    os.write_uint64(42, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mtval_oneof {
            match v {
                &ProcessorState_oneof_mtval_oneof::mtval(v) => {
                    os.write_uint64(43, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.misa_oneof {
            match v {
                &ProcessorState_oneof_misa_oneof::misa(v) => {
                    os.write_uint64(44, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mie_oneof {
            match v {
                &ProcessorState_oneof_mie_oneof::mie(v) => {
                    os.write_uint64(45, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mip_oneof {
            match v {
                &ProcessorState_oneof_mip_oneof::mip(v) => {
                    os.write_uint64(46, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.medeleg_oneof {
            match v {
                &ProcessorState_oneof_medeleg_oneof::medeleg(v) => {
                    os.write_uint64(47, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mideleg_oneof {
            match v {
                &ProcessorState_oneof_mideleg_oneof::mideleg(v) => {
                    os.write_uint64(48, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.mcounteren_oneof {
            match v {
                &ProcessorState_oneof_mcounteren_oneof::mcounteren(v) => {
                    os.write_uint64(49, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.stvec_oneof {
            match v {
                &ProcessorState_oneof_stvec_oneof::stvec(v) => {
                    os.write_uint64(50, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.sscratch_oneof {
            match v {
                &ProcessorState_oneof_sscratch_oneof::sscratch(v) => {
                    os.write_uint64(51, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.sepc_oneof {
            match v {
                &ProcessorState_oneof_sepc_oneof::sepc(v) => {
                    os.write_uint64(52, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.scause_oneof {
            match v {
                &ProcessorState_oneof_scause_oneof::scause(v) => {
                    os.write_uint64(53, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.stval_oneof {
            match v {
                &ProcessorState_oneof_stval_oneof::stval(v) => {
                    os.write_uint64(54, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.satp_oneof {
            match v {
                &ProcessorState_oneof_satp_oneof::satp(v) => {
                    os.write_uint64(55, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.scounteren_oneof {
            match v {
                &ProcessorState_oneof_scounteren_oneof::scounteren(v) => {
                    os.write_uint64(56, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.ilrsc_oneof {
            match v {
                &ProcessorState_oneof_ilrsc_oneof::ilrsc(v) => {
                    os.write_uint64(57, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.iflags_oneof {
            match v {
                &ProcessorState_oneof_iflags_oneof::iflags(v) => {
                    os.write_uint64(58, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcessorState {
        ProcessorState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x1",
                    ProcessorState::has_x1,
                    ProcessorState::get_x1,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x2",
                    ProcessorState::has_x2,
                    ProcessorState::get_x2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x3",
                    ProcessorState::has_x3,
                    ProcessorState::get_x3,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x4",
                    ProcessorState::has_x4,
                    ProcessorState::get_x4,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x5",
                    ProcessorState::has_x5,
                    ProcessorState::get_x5,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x6",
                    ProcessorState::has_x6,
                    ProcessorState::get_x6,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x7",
                    ProcessorState::has_x7,
                    ProcessorState::get_x7,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x8",
                    ProcessorState::has_x8,
                    ProcessorState::get_x8,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x9",
                    ProcessorState::has_x9,
                    ProcessorState::get_x9,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x10",
                    ProcessorState::has_x10,
                    ProcessorState::get_x10,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x11",
                    ProcessorState::has_x11,
                    ProcessorState::get_x11,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x12",
                    ProcessorState::has_x12,
                    ProcessorState::get_x12,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x13",
                    ProcessorState::has_x13,
                    ProcessorState::get_x13,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x14",
                    ProcessorState::has_x14,
                    ProcessorState::get_x14,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x15",
                    ProcessorState::has_x15,
                    ProcessorState::get_x15,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x16",
                    ProcessorState::has_x16,
                    ProcessorState::get_x16,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x17",
                    ProcessorState::has_x17,
                    ProcessorState::get_x17,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x18",
                    ProcessorState::has_x18,
                    ProcessorState::get_x18,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x19",
                    ProcessorState::has_x19,
                    ProcessorState::get_x19,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x20",
                    ProcessorState::has_x20,
                    ProcessorState::get_x20,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x21",
                    ProcessorState::has_x21,
                    ProcessorState::get_x21,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x22",
                    ProcessorState::has_x22,
                    ProcessorState::get_x22,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x23",
                    ProcessorState::has_x23,
                    ProcessorState::get_x23,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x24",
                    ProcessorState::has_x24,
                    ProcessorState::get_x24,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x25",
                    ProcessorState::has_x25,
                    ProcessorState::get_x25,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x26",
                    ProcessorState::has_x26,
                    ProcessorState::get_x26,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x27",
                    ProcessorState::has_x27,
                    ProcessorState::get_x27,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x28",
                    ProcessorState::has_x28,
                    ProcessorState::get_x28,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x29",
                    ProcessorState::has_x29,
                    ProcessorState::get_x29,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x30",
                    ProcessorState::has_x30,
                    ProcessorState::get_x30,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "x31",
                    ProcessorState::has_x31,
                    ProcessorState::get_x31,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "pc",
                    ProcessorState::has_pc,
                    ProcessorState::get_pc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mvendorid",
                    ProcessorState::has_mvendorid,
                    ProcessorState::get_mvendorid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "marchid",
                    ProcessorState::has_marchid,
                    ProcessorState::get_marchid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mimpid",
                    ProcessorState::has_mimpid,
                    ProcessorState::get_mimpid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mcycle",
                    ProcessorState::has_mcycle,
                    ProcessorState::get_mcycle,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "minstret",
                    ProcessorState::has_minstret,
                    ProcessorState::get_minstret,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mstatus",
                    ProcessorState::has_mstatus,
                    ProcessorState::get_mstatus,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mtvec",
                    ProcessorState::has_mtvec,
                    ProcessorState::get_mtvec,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mscratch",
                    ProcessorState::has_mscratch,
                    ProcessorState::get_mscratch,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mepc",
                    ProcessorState::has_mepc,
                    ProcessorState::get_mepc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mcause",
                    ProcessorState::has_mcause,
                    ProcessorState::get_mcause,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mtval",
                    ProcessorState::has_mtval,
                    ProcessorState::get_mtval,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "misa",
                    ProcessorState::has_misa,
                    ProcessorState::get_misa,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mie",
                    ProcessorState::has_mie,
                    ProcessorState::get_mie,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mip",
                    ProcessorState::has_mip,
                    ProcessorState::get_mip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "medeleg",
                    ProcessorState::has_medeleg,
                    ProcessorState::get_medeleg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mideleg",
                    ProcessorState::has_mideleg,
                    ProcessorState::get_mideleg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "mcounteren",
                    ProcessorState::has_mcounteren,
                    ProcessorState::get_mcounteren,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "stvec",
                    ProcessorState::has_stvec,
                    ProcessorState::get_stvec,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "sscratch",
                    ProcessorState::has_sscratch,
                    ProcessorState::get_sscratch,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "sepc",
                    ProcessorState::has_sepc,
                    ProcessorState::get_sepc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "scause",
                    ProcessorState::has_scause,
                    ProcessorState::get_scause,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "stval",
                    ProcessorState::has_stval,
                    ProcessorState::get_stval,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "satp",
                    ProcessorState::has_satp,
                    ProcessorState::get_satp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "scounteren",
                    ProcessorState::has_scounteren,
                    ProcessorState::get_scounteren,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "ilrsc",
                    ProcessorState::has_ilrsc,
                    ProcessorState::get_ilrsc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "iflags",
                    ProcessorState::has_iflags,
                    ProcessorState::get_iflags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcessorState>(
                    "ProcessorState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProcessorState {
        static mut instance: ::protobuf::lazy::Lazy<ProcessorState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProcessorState,
        };
        unsafe {
            instance.get(ProcessorState::new)
        }
    }
}

impl ::protobuf::Clear for ProcessorState {
    fn clear(&mut self) {
        self.x1_oneof = ::std::option::Option::None;
        self.x2_oneof = ::std::option::Option::None;
        self.x3_oneof = ::std::option::Option::None;
        self.x4_oneof = ::std::option::Option::None;
        self.x5_oneof = ::std::option::Option::None;
        self.x6_oneof = ::std::option::Option::None;
        self.x7_oneof = ::std::option::Option::None;
        self.x8_oneof = ::std::option::Option::None;
        self.x9_oneof = ::std::option::Option::None;
        self.x10_oneof = ::std::option::Option::None;
        self.x11_oneof = ::std::option::Option::None;
        self.x12_oneof = ::std::option::Option::None;
        self.x13_oneof = ::std::option::Option::None;
        self.x14_oneof = ::std::option::Option::None;
        self.x15_oneof = ::std::option::Option::None;
        self.x16_oneof = ::std::option::Option::None;
        self.x17_oneof = ::std::option::Option::None;
        self.x18_oneof = ::std::option::Option::None;
        self.x19_oneof = ::std::option::Option::None;
        self.x20_oneof = ::std::option::Option::None;
        self.x21_oneof = ::std::option::Option::None;
        self.x22_oneof = ::std::option::Option::None;
        self.x23_oneof = ::std::option::Option::None;
        self.x24_oneof = ::std::option::Option::None;
        self.x25_oneof = ::std::option::Option::None;
        self.x26_oneof = ::std::option::Option::None;
        self.x27_oneof = ::std::option::Option::None;
        self.x28_oneof = ::std::option::Option::None;
        self.x29_oneof = ::std::option::Option::None;
        self.x30_oneof = ::std::option::Option::None;
        self.x31_oneof = ::std::option::Option::None;
        self.pc_oneof = ::std::option::Option::None;
        self.mvendorid_oneof = ::std::option::Option::None;
        self.marchid_oneof = ::std::option::Option::None;
        self.mimpid_oneof = ::std::option::Option::None;
        self.mcycle_oneof = ::std::option::Option::None;
        self.minstret_oneof = ::std::option::Option::None;
        self.mstatus_oneof = ::std::option::Option::None;
        self.mtvec_oneof = ::std::option::Option::None;
        self.mscratch_oneof = ::std::option::Option::None;
        self.mepc_oneof = ::std::option::Option::None;
        self.mcause_oneof = ::std::option::Option::None;
        self.mtval_oneof = ::std::option::Option::None;
        self.misa_oneof = ::std::option::Option::None;
        self.mie_oneof = ::std::option::Option::None;
        self.mip_oneof = ::std::option::Option::None;
        self.medeleg_oneof = ::std::option::Option::None;
        self.mideleg_oneof = ::std::option::Option::None;
        self.mcounteren_oneof = ::std::option::Option::None;
        self.stvec_oneof = ::std::option::Option::None;
        self.sscratch_oneof = ::std::option::Option::None;
        self.sepc_oneof = ::std::option::Option::None;
        self.scause_oneof = ::std::option::Option::None;
        self.stval_oneof = ::std::option::Option::None;
        self.satp_oneof = ::std::option::Option::None;
        self.scounteren_oneof = ::std::option::Option::None;
        self.ilrsc_oneof = ::std::option::Option::None;
        self.iflags_oneof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcessorState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessorState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Processor {
    // message oneof groups
    pub processor_oneof: ::std::option::Option<Processor_oneof_processor_oneof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Processor {
    fn default() -> &'a Processor {
        <Processor as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Processor_oneof_processor_oneof {
    state(ProcessorState),
    backing(::std::string::String),
}

impl Processor {
    pub fn new() -> Processor {
        ::std::default::Default::default()
    }

    // .CartesiCore.ProcessorState state = 1;


    pub fn get_state(&self) -> &ProcessorState {
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::state(ref v)) => v,
            _ => ProcessorState::default_instance(),
        }
    }
    pub fn clear_state(&mut self) {
        self.processor_oneof = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ProcessorState) {
        self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut ProcessorState {
        if let ::std::option::Option::Some(Processor_oneof_processor_oneof::state(_)) = self.processor_oneof {
        } else {
            self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::state(ProcessorState::new()));
        }
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state(&mut self) -> ProcessorState {
        if self.has_state() {
            match self.processor_oneof.take() {
                ::std::option::Option::Some(Processor_oneof_processor_oneof::state(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessorState::new()
        }
    }

    // string backing = 2;


    pub fn get_backing(&self) -> &str {
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backing(&mut self) {
        self.processor_oneof = ::std::option::Option::None;
    }

    pub fn has_backing(&self) -> bool {
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(_)) = self.processor_oneof {
        } else {
            self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(::std::string::String::new()));
        }
        match self.processor_oneof {
            ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        if self.has_backing() {
            match self.processor_oneof.take() {
                ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Processor {
    fn is_initialized(&self) -> bool {
        if let Some(Processor_oneof_processor_oneof::state(ref v)) = self.processor_oneof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::state(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.processor_oneof = ::std::option::Option::Some(Processor_oneof_processor_oneof::backing(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.processor_oneof {
            match v {
                &Processor_oneof_processor_oneof::state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Processor_oneof_processor_oneof::backing(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.processor_oneof {
            match v {
                &Processor_oneof_processor_oneof::state(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Processor_oneof_processor_oneof::backing(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Processor {
        Processor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProcessorState>(
                    "state",
                    Processor::has_state,
                    Processor::get_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "backing",
                    Processor::has_backing,
                    Processor::get_backing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Processor>(
                    "Processor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Processor {
        static mut instance: ::protobuf::lazy::Lazy<Processor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Processor,
        };
        unsafe {
            instance.get(Processor::new)
        }
    }
}

impl ::protobuf::Clear for Processor {
    fn clear(&mut self) {
        self.processor_oneof = ::std::option::Option::None;
        self.processor_oneof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Processor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Processor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ROM {
    // message oneof groups
    pub rom_oneof: ::std::option::Option<ROM_oneof_rom_oneof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ROM {
    fn default() -> &'a ROM {
        <ROM as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ROM_oneof_rom_oneof {
    bootargs(::std::string::String),
    backing(::std::string::String),
}

impl ROM {
    pub fn new() -> ROM {
        ::std::default::Default::default()
    }

    // string bootargs = 1;


    pub fn get_bootargs(&self) -> &str {
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_bootargs(&mut self) {
        self.rom_oneof = ::std::option::Option::None;
    }

    pub fn has_bootargs(&self) -> bool {
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bootargs(&mut self, v: ::std::string::String) {
        self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bootargs(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(_)) = self.rom_oneof {
        } else {
            self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(::std::string::String::new()));
        }
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bootargs(&mut self) -> ::std::string::String {
        if self.has_bootargs() {
            match self.rom_oneof.take() {
                ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string backing = 2;


    pub fn get_backing(&self) -> &str {
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backing(&mut self) {
        self.rom_oneof = ::std::option::Option::None;
    }

    pub fn has_backing(&self) -> bool {
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(_)) = self.rom_oneof {
        } else {
            self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(::std::string::String::new()));
        }
        match self.rom_oneof {
            ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        if self.has_backing() {
            match self.rom_oneof.take() {
                ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ROM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::bootargs(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rom_oneof = ::std::option::Option::Some(ROM_oneof_rom_oneof::backing(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.rom_oneof {
            match v {
                &ROM_oneof_rom_oneof::bootargs(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &ROM_oneof_rom_oneof::backing(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.rom_oneof {
            match v {
                &ROM_oneof_rom_oneof::bootargs(ref v) => {
                    os.write_string(1, v)?;
                },
                &ROM_oneof_rom_oneof::backing(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ROM {
        ROM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "bootargs",
                    ROM::has_bootargs,
                    ROM::get_bootargs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "backing",
                    ROM::has_backing,
                    ROM::get_backing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ROM>(
                    "ROM",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ROM {
        static mut instance: ::protobuf::lazy::Lazy<ROM> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ROM,
        };
        unsafe {
            instance.get(ROM::new)
        }
    }
}

impl ::protobuf::Clear for ROM {
    fn clear(&mut self) {
        self.rom_oneof = ::std::option::Option::None;
        self.rom_oneof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ROM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ROM {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RAM {
    // message fields
    pub length: u64,
    pub backing: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RAM {
    fn default() -> &'a RAM {
        <RAM as ::protobuf::Message>::default_instance()
    }
}

impl RAM {
    pub fn new() -> RAM {
        ::std::default::Default::default()
    }

    // uint64 length = 1;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // string backing = 2;


    pub fn get_backing(&self) -> &str {
        &self.backing
    }
    pub fn clear_backing(&mut self) {
        self.backing.clear();
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.backing = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        &mut self.backing
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backing, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RAM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(1, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.backing.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.backing);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.length != 0 {
            os.write_uint64(1, self.length)?;
        }
        if !self.backing.is_empty() {
            os.write_string(2, &self.backing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RAM {
        RAM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &RAM| { &m.length },
                    |m: &mut RAM| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "backing",
                    |m: &RAM| { &m.backing },
                    |m: &mut RAM| { &mut m.backing },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RAM>(
                    "RAM",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RAM {
        static mut instance: ::protobuf::lazy::Lazy<RAM> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RAM,
        };
        unsafe {
            instance.get(RAM::new)
        }
    }
}

impl ::protobuf::Clear for RAM {
    fn clear(&mut self) {
        self.length = 0;
        self.backing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RAM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RAM {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Drive {
    // message fields
    pub start: u64,
    pub length: u64,
    pub backing: ::std::string::String,
    pub shared: bool,
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Drive {
    fn default() -> &'a Drive {
        <Drive as ::protobuf::Message>::default_instance()
    }
}

impl Drive {
    pub fn new() -> Drive {
        ::std::default::Default::default()
    }

    // uint64 start = 1;


    pub fn get_start(&self) -> u64 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = v;
    }

    // uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // string backing = 3;


    pub fn get_backing(&self) -> &str {
        &self.backing
    }
    pub fn clear_backing(&mut self) {
        self.backing.clear();
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.backing = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        &mut self.backing
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backing, ::std::string::String::new())
    }

    // bool shared = 4;


    pub fn get_shared(&self) -> bool {
        self.shared
    }
    pub fn clear_shared(&mut self) {
        self.shared = false;
    }

    // Param is passed by value, moved
    pub fn set_shared(&mut self, v: bool) {
        self.shared = v;
    }

    // string label = 5;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Drive {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backing)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shared = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.backing.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.backing);
        }
        if self.shared != false {
            my_size += 2;
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start != 0 {
            os.write_uint64(1, self.start)?;
        }
        if self.length != 0 {
            os.write_uint64(2, self.length)?;
        }
        if !self.backing.is_empty() {
            os.write_string(3, &self.backing)?;
        }
        if self.shared != false {
            os.write_bool(4, self.shared)?;
        }
        if !self.label.is_empty() {
            os.write_string(5, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Drive {
        Drive::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start",
                    |m: &Drive| { &m.start },
                    |m: &mut Drive| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &Drive| { &m.length },
                    |m: &mut Drive| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "backing",
                    |m: &Drive| { &m.backing },
                    |m: &mut Drive| { &mut m.backing },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "shared",
                    |m: &Drive| { &m.shared },
                    |m: &mut Drive| { &mut m.shared },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Drive| { &m.label },
                    |m: &mut Drive| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Drive>(
                    "Drive",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Drive {
        static mut instance: ::protobuf::lazy::Lazy<Drive> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Drive,
        };
        unsafe {
            instance.get(Drive::new)
        }
    }
}

impl ::protobuf::Clear for Drive {
    fn clear(&mut self) {
        self.start = 0;
        self.length = 0;
        self.backing.clear();
        self.shared = false;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Drive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Drive {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLINTState {
    // message fields
    pub mtime: u64,
    pub mtimecmp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLINTState {
    fn default() -> &'a CLINTState {
        <CLINTState as ::protobuf::Message>::default_instance()
    }
}

impl CLINTState {
    pub fn new() -> CLINTState {
        ::std::default::Default::default()
    }

    // uint64 mtime = 1;


    pub fn get_mtime(&self) -> u64 {
        self.mtime
    }
    pub fn clear_mtime(&mut self) {
        self.mtime = 0;
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = v;
    }

    // uint64 mtimecmp = 2;


    pub fn get_mtimecmp(&self) -> u64 {
        self.mtimecmp
    }
    pub fn clear_mtimecmp(&mut self) {
        self.mtimecmp = 0;
    }

    // Param is passed by value, moved
    pub fn set_mtimecmp(&mut self, v: u64) {
        self.mtimecmp = v;
    }
}

impl ::protobuf::Message for CLINTState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtimecmp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mtime != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mtime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mtimecmp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mtimecmp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mtime != 0 {
            os.write_uint64(1, self.mtime)?;
        }
        if self.mtimecmp != 0 {
            os.write_uint64(2, self.mtimecmp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLINTState {
        CLINTState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mtime",
                    |m: &CLINTState| { &m.mtime },
                    |m: &mut CLINTState| { &mut m.mtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mtimecmp",
                    |m: &CLINTState| { &m.mtimecmp },
                    |m: &mut CLINTState| { &mut m.mtimecmp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CLINTState>(
                    "CLINTState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CLINTState {
        static mut instance: ::protobuf::lazy::Lazy<CLINTState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CLINTState,
        };
        unsafe {
            instance.get(CLINTState::new)
        }
    }
}

impl ::protobuf::Clear for CLINTState {
    fn clear(&mut self) {
        self.mtime = 0;
        self.mtimecmp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLINTState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLINTState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLINT {
    // message oneof groups
    pub clint_oneof: ::std::option::Option<CLINT_oneof_clint_oneof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLINT {
    fn default() -> &'a CLINT {
        <CLINT as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CLINT_oneof_clint_oneof {
    state(CLINTState),
    backing(::std::string::String),
}

impl CLINT {
    pub fn new() -> CLINT {
        ::std::default::Default::default()
    }

    // .CartesiCore.CLINTState state = 1;


    pub fn get_state(&self) -> &CLINTState {
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(ref v)) => v,
            _ => CLINTState::default_instance(),
        }
    }
    pub fn clear_state(&mut self) {
        self.clint_oneof = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CLINTState) {
        self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut CLINTState {
        if let ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(_)) = self.clint_oneof {
        } else {
            self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(CLINTState::new()));
        }
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state(&mut self) -> CLINTState {
        if self.has_state() {
            match self.clint_oneof.take() {
                ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(v)) => v,
                _ => panic!(),
            }
        } else {
            CLINTState::new()
        }
    }

    // string backing = 2;


    pub fn get_backing(&self) -> &str {
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backing(&mut self) {
        self.clint_oneof = ::std::option::Option::None;
    }

    pub fn has_backing(&self) -> bool {
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(_)) = self.clint_oneof {
        } else {
            self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(::std::string::String::new()));
        }
        match self.clint_oneof {
            ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        if self.has_backing() {
            match self.clint_oneof.take() {
                ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for CLINT {
    fn is_initialized(&self) -> bool {
        if let Some(CLINT_oneof_clint_oneof::state(ref v)) = self.clint_oneof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::state(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clint_oneof = ::std::option::Option::Some(CLINT_oneof_clint_oneof::backing(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.clint_oneof {
            match v {
                &CLINT_oneof_clint_oneof::state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CLINT_oneof_clint_oneof::backing(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.clint_oneof {
            match v {
                &CLINT_oneof_clint_oneof::state(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CLINT_oneof_clint_oneof::backing(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLINT {
        CLINT::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CLINTState>(
                    "state",
                    CLINT::has_state,
                    CLINT::get_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "backing",
                    CLINT::has_backing,
                    CLINT::get_backing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CLINT>(
                    "CLINT",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CLINT {
        static mut instance: ::protobuf::lazy::Lazy<CLINT> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CLINT,
        };
        unsafe {
            instance.get(CLINT::new)
        }
    }
}

impl ::protobuf::Clear for CLINT {
    fn clear(&mut self) {
        self.clint_oneof = ::std::option::Option::None;
        self.clint_oneof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLINT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLINT {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTIFState {
    // message fields
    pub fromhost: u64,
    pub tohost: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTIFState {
    fn default() -> &'a HTIFState {
        <HTIFState as ::protobuf::Message>::default_instance()
    }
}

impl HTIFState {
    pub fn new() -> HTIFState {
        ::std::default::Default::default()
    }

    // uint64 fromhost = 1;


    pub fn get_fromhost(&self) -> u64 {
        self.fromhost
    }
    pub fn clear_fromhost(&mut self) {
        self.fromhost = 0;
    }

    // Param is passed by value, moved
    pub fn set_fromhost(&mut self, v: u64) {
        self.fromhost = v;
    }

    // uint64 tohost = 2;


    pub fn get_tohost(&self) -> u64 {
        self.tohost
    }
    pub fn clear_tohost(&mut self) {
        self.tohost = 0;
    }

    // Param is passed by value, moved
    pub fn set_tohost(&mut self, v: u64) {
        self.tohost = v;
    }
}

impl ::protobuf::Message for HTIFState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fromhost = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tohost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fromhost != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fromhost, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tohost != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tohost, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.fromhost != 0 {
            os.write_uint64(1, self.fromhost)?;
        }
        if self.tohost != 0 {
            os.write_uint64(2, self.tohost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTIFState {
        HTIFState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fromhost",
                    |m: &HTIFState| { &m.fromhost },
                    |m: &mut HTIFState| { &mut m.fromhost },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tohost",
                    |m: &HTIFState| { &m.tohost },
                    |m: &mut HTIFState| { &mut m.tohost },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTIFState>(
                    "HTIFState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTIFState {
        static mut instance: ::protobuf::lazy::Lazy<HTIFState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTIFState,
        };
        unsafe {
            instance.get(HTIFState::new)
        }
    }
}

impl ::protobuf::Clear for HTIFState {
    fn clear(&mut self) {
        self.fromhost = 0;
        self.tohost = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTIFState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTIFState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTIF {
    // message oneof groups
    pub htif_oneof: ::std::option::Option<HTIF_oneof_htif_oneof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTIF {
    fn default() -> &'a HTIF {
        <HTIF as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HTIF_oneof_htif_oneof {
    state(HTIFState),
    backing(::std::string::String),
}

impl HTIF {
    pub fn new() -> HTIF {
        ::std::default::Default::default()
    }

    // .CartesiCore.HTIFState state = 1;


    pub fn get_state(&self) -> &HTIFState {
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(ref v)) => v,
            _ => HTIFState::default_instance(),
        }
    }
    pub fn clear_state(&mut self) {
        self.htif_oneof = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: HTIFState) {
        self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut HTIFState {
        if let ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(_)) = self.htif_oneof {
        } else {
            self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(HTIFState::new()));
        }
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state(&mut self) -> HTIFState {
        if self.has_state() {
            match self.htif_oneof.take() {
                ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(v)) => v,
                _ => panic!(),
            }
        } else {
            HTIFState::new()
        }
    }

    // string backing = 2;


    pub fn get_backing(&self) -> &str {
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backing(&mut self) {
        self.htif_oneof = ::std::option::Option::None;
    }

    pub fn has_backing(&self) -> bool {
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backing(&mut self, v: ::std::string::String) {
        self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backing(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(_)) = self.htif_oneof {
        } else {
            self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(::std::string::String::new()));
        }
        match self.htif_oneof {
            ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backing(&mut self) -> ::std::string::String {
        if self.has_backing() {
            match self.htif_oneof.take() {
                ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for HTIF {
    fn is_initialized(&self) -> bool {
        if let Some(HTIF_oneof_htif_oneof::state(ref v)) = self.htif_oneof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::state(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.htif_oneof = ::std::option::Option::Some(HTIF_oneof_htif_oneof::backing(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.htif_oneof {
            match v {
                &HTIF_oneof_htif_oneof::state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HTIF_oneof_htif_oneof::backing(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.htif_oneof {
            match v {
                &HTIF_oneof_htif_oneof::state(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HTIF_oneof_htif_oneof::backing(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTIF {
        HTIF::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HTIFState>(
                    "state",
                    HTIF::has_state,
                    HTIF::get_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "backing",
                    HTIF::has_backing,
                    HTIF::get_backing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTIF>(
                    "HTIF",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTIF {
        static mut instance: ::protobuf::lazy::Lazy<HTIF> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTIF,
        };
        unsafe {
            instance.get(HTIF::new)
        }
    }
}

impl ::protobuf::Clear for HTIF {
    fn clear(&mut self) {
        self.htif_oneof = ::std::option::Option::None;
        self.htif_oneof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTIF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTIF {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MachineRequest {
    // message fields
    pub processor: ::protobuf::SingularPtrField<Processor>,
    pub rom: ::protobuf::SingularPtrField<ROM>,
    pub ram: ::protobuf::SingularPtrField<RAM>,
    pub flash: ::protobuf::RepeatedField<Drive>,
    pub clint: ::protobuf::SingularPtrField<CLINT>,
    pub htif: ::protobuf::SingularPtrField<HTIF>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MachineRequest {
    fn default() -> &'a MachineRequest {
        <MachineRequest as ::protobuf::Message>::default_instance()
    }
}

impl MachineRequest {
    pub fn new() -> MachineRequest {
        ::std::default::Default::default()
    }

    // .CartesiCore.Processor processor = 1;


    pub fn get_processor(&self) -> &Processor {
        self.processor.as_ref().unwrap_or_else(|| Processor::default_instance())
    }
    pub fn clear_processor(&mut self) {
        self.processor.clear();
    }

    pub fn has_processor(&self) -> bool {
        self.processor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processor(&mut self, v: Processor) {
        self.processor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processor(&mut self) -> &mut Processor {
        if self.processor.is_none() {
            self.processor.set_default();
        }
        self.processor.as_mut().unwrap()
    }

    // Take field
    pub fn take_processor(&mut self) -> Processor {
        self.processor.take().unwrap_or_else(|| Processor::new())
    }

    // .CartesiCore.ROM rom = 2;


    pub fn get_rom(&self) -> &ROM {
        self.rom.as_ref().unwrap_or_else(|| ROM::default_instance())
    }
    pub fn clear_rom(&mut self) {
        self.rom.clear();
    }

    pub fn has_rom(&self) -> bool {
        self.rom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rom(&mut self, v: ROM) {
        self.rom = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rom(&mut self) -> &mut ROM {
        if self.rom.is_none() {
            self.rom.set_default();
        }
        self.rom.as_mut().unwrap()
    }

    // Take field
    pub fn take_rom(&mut self) -> ROM {
        self.rom.take().unwrap_or_else(|| ROM::new())
    }

    // .CartesiCore.RAM ram = 3;


    pub fn get_ram(&self) -> &RAM {
        self.ram.as_ref().unwrap_or_else(|| RAM::default_instance())
    }
    pub fn clear_ram(&mut self) {
        self.ram.clear();
    }

    pub fn has_ram(&self) -> bool {
        self.ram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ram(&mut self, v: RAM) {
        self.ram = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ram(&mut self) -> &mut RAM {
        if self.ram.is_none() {
            self.ram.set_default();
        }
        self.ram.as_mut().unwrap()
    }

    // Take field
    pub fn take_ram(&mut self) -> RAM {
        self.ram.take().unwrap_or_else(|| RAM::new())
    }

    // repeated .CartesiCore.Drive flash = 4;


    pub fn get_flash(&self) -> &[Drive] {
        &self.flash
    }
    pub fn clear_flash(&mut self) {
        self.flash.clear();
    }

    // Param is passed by value, moved
    pub fn set_flash(&mut self, v: ::protobuf::RepeatedField<Drive>) {
        self.flash = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flash(&mut self) -> &mut ::protobuf::RepeatedField<Drive> {
        &mut self.flash
    }

    // Take field
    pub fn take_flash(&mut self) -> ::protobuf::RepeatedField<Drive> {
        ::std::mem::replace(&mut self.flash, ::protobuf::RepeatedField::new())
    }

    // .CartesiCore.CLINT clint = 5;


    pub fn get_clint(&self) -> &CLINT {
        self.clint.as_ref().unwrap_or_else(|| CLINT::default_instance())
    }
    pub fn clear_clint(&mut self) {
        self.clint.clear();
    }

    pub fn has_clint(&self) -> bool {
        self.clint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clint(&mut self, v: CLINT) {
        self.clint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clint(&mut self) -> &mut CLINT {
        if self.clint.is_none() {
            self.clint.set_default();
        }
        self.clint.as_mut().unwrap()
    }

    // Take field
    pub fn take_clint(&mut self) -> CLINT {
        self.clint.take().unwrap_or_else(|| CLINT::new())
    }

    // .CartesiCore.HTIF htif = 6;


    pub fn get_htif(&self) -> &HTIF {
        self.htif.as_ref().unwrap_or_else(|| HTIF::default_instance())
    }
    pub fn clear_htif(&mut self) {
        self.htif.clear();
    }

    pub fn has_htif(&self) -> bool {
        self.htif.is_some()
    }

    // Param is passed by value, moved
    pub fn set_htif(&mut self, v: HTIF) {
        self.htif = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_htif(&mut self) -> &mut HTIF {
        if self.htif.is_none() {
            self.htif.set_default();
        }
        self.htif.as_mut().unwrap()
    }

    // Take field
    pub fn take_htif(&mut self) -> HTIF {
        self.htif.take().unwrap_or_else(|| HTIF::new())
    }
}

impl ::protobuf::Message for MachineRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.processor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rom {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ram {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.htif {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processor)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ram)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.flash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clint)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.htif)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.processor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ram.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.flash {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.clint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.htif.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.processor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rom.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ram.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.flash {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.clint.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.htif.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MachineRequest {
        MachineRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Processor>>(
                    "processor",
                    |m: &MachineRequest| { &m.processor },
                    |m: &mut MachineRequest| { &mut m.processor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ROM>>(
                    "rom",
                    |m: &MachineRequest| { &m.rom },
                    |m: &mut MachineRequest| { &mut m.rom },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RAM>>(
                    "ram",
                    |m: &MachineRequest| { &m.ram },
                    |m: &mut MachineRequest| { &mut m.ram },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Drive>>(
                    "flash",
                    |m: &MachineRequest| { &m.flash },
                    |m: &mut MachineRequest| { &mut m.flash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CLINT>>(
                    "clint",
                    |m: &MachineRequest| { &m.clint },
                    |m: &mut MachineRequest| { &mut m.clint },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTIF>>(
                    "htif",
                    |m: &MachineRequest| { &m.htif },
                    |m: &mut MachineRequest| { &mut m.htif },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MachineRequest>(
                    "MachineRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MachineRequest {
        static mut instance: ::protobuf::lazy::Lazy<MachineRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MachineRequest,
        };
        unsafe {
            instance.get(MachineRequest::new)
        }
    }
}

impl ::protobuf::Clear for MachineRequest {
    fn clear(&mut self) {
        self.processor.clear();
        self.rom.clear();
        self.ram.clear();
        self.flash.clear();
        self.clint.clear();
        self.htif.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MachineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MachineRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunRequest {
    // message fields
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunRequest {
    fn default() -> &'a RunRequest {
        <RunRequest as ::protobuf::Message>::default_instance()
    }
}

impl RunRequest {
    pub fn new() -> RunRequest {
        ::std::default::Default::default()
    }

    // uint64 limit = 1;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for RunRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_uint64(1, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunRequest {
        RunRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &RunRequest| { &m.limit },
                    |m: &mut RunRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunRequest>(
                    "RunRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunRequest {
        static mut instance: ::protobuf::lazy::Lazy<RunRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunRequest,
        };
        unsafe {
            instance.get(RunRequest::new)
        }
    }
}

impl ::protobuf::Clear for RunRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunResponse {
    // message fields
    pub mcycle: u64,
    pub tohost: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunResponse {
    fn default() -> &'a RunResponse {
        <RunResponse as ::protobuf::Message>::default_instance()
    }
}

impl RunResponse {
    pub fn new() -> RunResponse {
        ::std::default::Default::default()
    }

    // uint64 mcycle = 1;


    pub fn get_mcycle(&self) -> u64 {
        self.mcycle
    }
    pub fn clear_mcycle(&mut self) {
        self.mcycle = 0;
    }

    // Param is passed by value, moved
    pub fn set_mcycle(&mut self, v: u64) {
        self.mcycle = v;
    }

    // uint64 tohost = 2;


    pub fn get_tohost(&self) -> u64 {
        self.tohost
    }
    pub fn clear_tohost(&mut self) {
        self.tohost = 0;
    }

    // Param is passed by value, moved
    pub fn set_tohost(&mut self, v: u64) {
        self.tohost = v;
    }
}

impl ::protobuf::Message for RunResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mcycle = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tohost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mcycle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mcycle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tohost != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tohost, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mcycle != 0 {
            os.write_uint64(1, self.mcycle)?;
        }
        if self.tohost != 0 {
            os.write_uint64(2, self.tohost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunResponse {
        RunResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mcycle",
                    |m: &RunResponse| { &m.mcycle },
                    |m: &mut RunResponse| { &mut m.mcycle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tohost",
                    |m: &RunResponse| { &m.tohost },
                    |m: &mut RunResponse| { &mut m.tohost },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunResponse>(
                    "RunResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunResponse {
        static mut instance: ::protobuf::lazy::Lazy<RunResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunResponse,
        };
        unsafe {
            instance.get(RunResponse::new)
        }
    }
}

impl ::protobuf::Clear for RunResponse {
    fn clear(&mut self) {
        self.mcycle = 0;
        self.tohost = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Proof {
    // message fields
    pub address: u64,
    pub log2_size: u32,
    pub target_hash: ::protobuf::SingularPtrField<Hash>,
    pub sibling_hashes: ::protobuf::RepeatedField<Hash>,
    pub root_hash: ::protobuf::SingularPtrField<Hash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proof {
    fn default() -> &'a Proof {
        <Proof as ::protobuf::Message>::default_instance()
    }
}

impl Proof {
    pub fn new() -> Proof {
        ::std::default::Default::default()
    }

    // uint64 address = 1;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // uint32 log2_size = 2;


    pub fn get_log2_size(&self) -> u32 {
        self.log2_size
    }
    pub fn clear_log2_size(&mut self) {
        self.log2_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_log2_size(&mut self, v: u32) {
        self.log2_size = v;
    }

    // .CartesiCore.Hash target_hash = 3;


    pub fn get_target_hash(&self) -> &Hash {
        self.target_hash.as_ref().unwrap_or_else(|| Hash::default_instance())
    }
    pub fn clear_target_hash(&mut self) {
        self.target_hash.clear();
    }

    pub fn has_target_hash(&self) -> bool {
        self.target_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hash(&mut self, v: Hash) {
        self.target_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_hash(&mut self) -> &mut Hash {
        if self.target_hash.is_none() {
            self.target_hash.set_default();
        }
        self.target_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_hash(&mut self) -> Hash {
        self.target_hash.take().unwrap_or_else(|| Hash::new())
    }

    // repeated .CartesiCore.Hash sibling_hashes = 4;


    pub fn get_sibling_hashes(&self) -> &[Hash] {
        &self.sibling_hashes
    }
    pub fn clear_sibling_hashes(&mut self) {
        self.sibling_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sibling_hashes(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.sibling_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sibling_hashes(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.sibling_hashes
    }

    // Take field
    pub fn take_sibling_hashes(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.sibling_hashes, ::protobuf::RepeatedField::new())
    }

    // .CartesiCore.Hash root_hash = 5;


    pub fn get_root_hash(&self) -> &Hash {
        self.root_hash.as_ref().unwrap_or_else(|| Hash::default_instance())
    }
    pub fn clear_root_hash(&mut self) {
        self.root_hash.clear();
    }

    pub fn has_root_hash(&self) -> bool {
        self.root_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_hash(&mut self, v: Hash) {
        self.root_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_hash(&mut self) -> &mut Hash {
        if self.root_hash.is_none() {
            self.root_hash.set_default();
        }
        self.root_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_root_hash(&mut self) -> Hash {
        self.root_hash.take().unwrap_or_else(|| Hash::new())
    }
}

impl ::protobuf::Message for Proof {
    fn is_initialized(&self) -> bool {
        for v in &self.target_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sibling_hashes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.root_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.log2_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sibling_hashes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.root_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.log2_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.log2_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.sibling_hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.root_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.log2_size != 0 {
            os.write_uint32(2, self.log2_size)?;
        }
        if let Some(ref v) = self.target_hash.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.sibling_hashes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.root_hash.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proof {
        Proof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "address",
                    |m: &Proof| { &m.address },
                    |m: &mut Proof| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "log2_size",
                    |m: &Proof| { &m.log2_size },
                    |m: &mut Proof| { &mut m.log2_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "target_hash",
                    |m: &Proof| { &m.target_hash },
                    |m: &mut Proof| { &mut m.target_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "sibling_hashes",
                    |m: &Proof| { &m.sibling_hashes },
                    |m: &mut Proof| { &mut m.sibling_hashes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "root_hash",
                    |m: &Proof| { &m.root_hash },
                    |m: &mut Proof| { &mut m.root_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Proof>(
                    "Proof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Proof {
        static mut instance: ::protobuf::lazy::Lazy<Proof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Proof,
        };
        unsafe {
            instance.get(Proof::new)
        }
    }
}

impl ::protobuf::Clear for Proof {
    fn clear(&mut self) {
        self.address = 0;
        self.log2_size = 0;
        self.target_hash.clear();
        self.sibling_hashes.clear();
        self.root_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Word {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Word {
    fn default() -> &'a Word {
        <Word as ::protobuf::Message>::default_instance()
    }
}

impl Word {
    pub fn new() -> Word {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Word {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Word {
        Word::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "content",
                    |m: &Word| { &m.content },
                    |m: &mut Word| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Word>(
                    "Word",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Word {
        static mut instance: ::protobuf::lazy::Lazy<Word> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Word,
        };
        unsafe {
            instance.get(Word::new)
        }
    }
}

impl ::protobuf::Clear for Word {
    fn clear(&mut self) {
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Word {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Word {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Access {
    // message fields
    pub operation: AccessOperation,
    pub read: ::protobuf::SingularPtrField<Word>,
    pub written: ::protobuf::SingularPtrField<Word>,
    pub proof: ::protobuf::SingularPtrField<Proof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Access {
    fn default() -> &'a Access {
        <Access as ::protobuf::Message>::default_instance()
    }
}

impl Access {
    pub fn new() -> Access {
        ::std::default::Default::default()
    }

    // .CartesiCore.AccessOperation operation = 1;


    pub fn get_operation(&self) -> AccessOperation {
        self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation = AccessOperation::READ;
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: AccessOperation) {
        self.operation = v;
    }

    // .CartesiCore.Word read = 2;


    pub fn get_read(&self) -> &Word {
        self.read.as_ref().unwrap_or_else(|| Word::default_instance())
    }
    pub fn clear_read(&mut self) {
        self.read.clear();
    }

    pub fn has_read(&self) -> bool {
        self.read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: Word) {
        self.read = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read(&mut self) -> &mut Word {
        if self.read.is_none() {
            self.read.set_default();
        }
        self.read.as_mut().unwrap()
    }

    // Take field
    pub fn take_read(&mut self) -> Word {
        self.read.take().unwrap_or_else(|| Word::new())
    }

    // .CartesiCore.Word written = 3;


    pub fn get_written(&self) -> &Word {
        self.written.as_ref().unwrap_or_else(|| Word::default_instance())
    }
    pub fn clear_written(&mut self) {
        self.written.clear();
    }

    pub fn has_written(&self) -> bool {
        self.written.is_some()
    }

    // Param is passed by value, moved
    pub fn set_written(&mut self, v: Word) {
        self.written = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_written(&mut self) -> &mut Word {
        if self.written.is_none() {
            self.written.set_default();
        }
        self.written.as_mut().unwrap()
    }

    // Take field
    pub fn take_written(&mut self) -> Word {
        self.written.take().unwrap_or_else(|| Word::new())
    }

    // .CartesiCore.Proof proof = 4;


    pub fn get_proof(&self) -> &Proof {
        self.proof.as_ref().unwrap_or_else(|| Proof::default_instance())
    }
    pub fn clear_proof(&mut self) {
        self.proof.clear();
    }

    pub fn has_proof(&self) -> bool {
        self.proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof(&mut self, v: Proof) {
        self.proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof(&mut self) -> &mut Proof {
        if self.proof.is_none() {
            self.proof.set_default();
        }
        self.proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof(&mut self) -> Proof {
        self.proof.take().unwrap_or_else(|| Proof::new())
    }
}

impl ::protobuf::Message for Access {
    fn is_initialized(&self) -> bool {
        for v in &self.read {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.written {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.written)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.operation != AccessOperation::READ {
            my_size += ::protobuf::rt::enum_size(1, self.operation);
        }
        if let Some(ref v) = self.read.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.written.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.operation != AccessOperation::READ {
            os.write_enum(1, self.operation.value())?;
        }
        if let Some(ref v) = self.read.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.written.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.proof.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Access {
        Access::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessOperation>>(
                    "operation",
                    |m: &Access| { &m.operation },
                    |m: &mut Access| { &mut m.operation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Word>>(
                    "read",
                    |m: &Access| { &m.read },
                    |m: &mut Access| { &mut m.read },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Word>>(
                    "written",
                    |m: &Access| { &m.written },
                    |m: &mut Access| { &mut m.written },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Proof>>(
                    "proof",
                    |m: &Access| { &m.proof },
                    |m: &mut Access| { &mut m.proof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Access>(
                    "Access",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Access {
        static mut instance: ::protobuf::lazy::Lazy<Access> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Access,
        };
        unsafe {
            instance.get(Access::new)
        }
    }
}

impl ::protobuf::Clear for Access {
    fn clear(&mut self) {
        self.operation = AccessOperation::READ;
        self.read.clear();
        self.written.clear();
        self.proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Access {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Access {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BracketNote {
    // message fields
    pub field_type: BracketNote_BracketNoteType,
    pub field_where: u64,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BracketNote {
    fn default() -> &'a BracketNote {
        <BracketNote as ::protobuf::Message>::default_instance()
    }
}

impl BracketNote {
    pub fn new() -> BracketNote {
        ::std::default::Default::default()
    }

    // .CartesiCore.BracketNote.BracketNoteType type = 1;


    pub fn get_field_type(&self) -> BracketNote_BracketNoteType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = BracketNote_BracketNoteType::DUMMY;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BracketNote_BracketNoteType) {
        self.field_type = v;
    }

    // uint64 where = 2;


    pub fn get_field_where(&self) -> u64 {
        self.field_where
    }
    pub fn clear_field_where(&mut self) {
        self.field_where = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_where(&mut self, v: u64) {
        self.field_where = v;
    }

    // string text = 3;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BracketNote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.field_where = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != BracketNote_BracketNoteType::DUMMY {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.field_where != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_where, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != BracketNote_BracketNoteType::DUMMY {
            os.write_enum(1, self.field_type.value())?;
        }
        if self.field_where != 0 {
            os.write_uint64(2, self.field_where)?;
        }
        if !self.text.is_empty() {
            os.write_string(3, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BracketNote {
        BracketNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BracketNote_BracketNoteType>>(
                    "type",
                    |m: &BracketNote| { &m.field_type },
                    |m: &mut BracketNote| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "where",
                    |m: &BracketNote| { &m.field_where },
                    |m: &mut BracketNote| { &mut m.field_where },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &BracketNote| { &m.text },
                    |m: &mut BracketNote| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BracketNote>(
                    "BracketNote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BracketNote {
        static mut instance: ::protobuf::lazy::Lazy<BracketNote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BracketNote,
        };
        unsafe {
            instance.get(BracketNote::new)
        }
    }
}

impl ::protobuf::Clear for BracketNote {
    fn clear(&mut self) {
        self.field_type = BracketNote_BracketNoteType::DUMMY;
        self.field_where = 0;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BracketNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BracketNote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BracketNote_BracketNoteType {
    DUMMY = 0,
    BEGIN = 1,
    END = 2,
    INVALID = 3,
}

impl ::protobuf::ProtobufEnum for BracketNote_BracketNoteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BracketNote_BracketNoteType> {
        match value {
            0 => ::std::option::Option::Some(BracketNote_BracketNoteType::DUMMY),
            1 => ::std::option::Option::Some(BracketNote_BracketNoteType::BEGIN),
            2 => ::std::option::Option::Some(BracketNote_BracketNoteType::END),
            3 => ::std::option::Option::Some(BracketNote_BracketNoteType::INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BracketNote_BracketNoteType] = &[
            BracketNote_BracketNoteType::DUMMY,
            BracketNote_BracketNoteType::BEGIN,
            BracketNote_BracketNoteType::END,
            BracketNote_BracketNoteType::INVALID,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BracketNote_BracketNoteType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BracketNote_BracketNoteType {
}

impl ::std::default::Default for BracketNote_BracketNoteType {
    fn default() -> Self {
        BracketNote_BracketNoteType::DUMMY
    }
}

impl ::protobuf::reflect::ProtobufValue for BracketNote_BracketNoteType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadMemoryRequest {
    // message fields
    pub address: u64,
    pub length: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadMemoryRequest {
    fn default() -> &'a ReadMemoryRequest {
        <ReadMemoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadMemoryRequest {
    pub fn new() -> ReadMemoryRequest {
        ::std::default::Default::default()
    }

    // uint64 address = 1;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }
}

impl ::protobuf::Message for ReadMemoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.length != 0 {
            os.write_uint64(2, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadMemoryRequest {
        ReadMemoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "address",
                    |m: &ReadMemoryRequest| { &m.address },
                    |m: &mut ReadMemoryRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &ReadMemoryRequest| { &m.length },
                    |m: &mut ReadMemoryRequest| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadMemoryRequest>(
                    "ReadMemoryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadMemoryRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadMemoryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadMemoryRequest,
        };
        unsafe {
            instance.get(ReadMemoryRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadMemoryRequest {
    fn clear(&mut self) {
        self.address = 0;
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadMemoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadMemoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadMemoryResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadMemoryResponse {
    fn default() -> &'a ReadMemoryResponse {
        <ReadMemoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadMemoryResponse {
    pub fn new() -> ReadMemoryResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadMemoryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadMemoryResponse {
        ReadMemoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ReadMemoryResponse| { &m.data },
                    |m: &mut ReadMemoryResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadMemoryResponse>(
                    "ReadMemoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadMemoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadMemoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadMemoryResponse,
        };
        unsafe {
            instance.get(ReadMemoryResponse::new)
        }
    }
}

impl ::protobuf::Clear for ReadMemoryResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadMemoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadMemoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetProofRequest {
    // message fields
    pub address: u64,
    pub log2_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProofRequest {
    fn default() -> &'a GetProofRequest {
        <GetProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProofRequest {
    pub fn new() -> GetProofRequest {
        ::std::default::Default::default()
    }

    // uint64 address = 1;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // uint64 log2_size = 2;


    pub fn get_log2_size(&self) -> u64 {
        self.log2_size
    }
    pub fn clear_log2_size(&mut self) {
        self.log2_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_log2_size(&mut self, v: u64) {
        self.log2_size = v;
    }
}

impl ::protobuf::Message for GetProofRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.log2_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.log2_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.log2_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.log2_size != 0 {
            os.write_uint64(2, self.log2_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProofRequest {
        GetProofRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "address",
                    |m: &GetProofRequest| { &m.address },
                    |m: &mut GetProofRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "log2_size",
                    |m: &GetProofRequest| { &m.log2_size },
                    |m: &mut GetProofRequest| { &mut m.log2_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetProofRequest>(
                    "GetProofRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetProofRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetProofRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetProofRequest,
        };
        unsafe {
            instance.get(GetProofRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetProofRequest {
    fn clear(&mut self) {
        self.address = 0;
        self.log2_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProofRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteMemoryRequest {
    // message fields
    pub address: u64,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteMemoryRequest {
    fn default() -> &'a WriteMemoryRequest {
        <WriteMemoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteMemoryRequest {
    pub fn new() -> WriteMemoryRequest {
        ::std::default::Default::default()
    }

    // uint64 address = 1;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WriteMemoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteMemoryRequest {
        WriteMemoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "address",
                    |m: &WriteMemoryRequest| { &m.address },
                    |m: &mut WriteMemoryRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &WriteMemoryRequest| { &m.data },
                    |m: &mut WriteMemoryRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteMemoryRequest>(
                    "WriteMemoryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteMemoryRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteMemoryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteMemoryRequest,
        };
        unsafe {
            instance.get(WriteMemoryRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteMemoryRequest {
    fn clear(&mut self) {
        self.address = 0;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteMemoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteMemoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccessLog {
    // message fields
    pub accesses: ::protobuf::RepeatedField<Access>,
    pub brackets: ::protobuf::RepeatedField<BracketNote>,
    pub notes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccessLog {
    fn default() -> &'a AccessLog {
        <AccessLog as ::protobuf::Message>::default_instance()
    }
}

impl AccessLog {
    pub fn new() -> AccessLog {
        ::std::default::Default::default()
    }

    // repeated .CartesiCore.Access accesses = 1;


    pub fn get_accesses(&self) -> &[Access] {
        &self.accesses
    }
    pub fn clear_accesses(&mut self) {
        self.accesses.clear();
    }

    // Param is passed by value, moved
    pub fn set_accesses(&mut self, v: ::protobuf::RepeatedField<Access>) {
        self.accesses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accesses(&mut self) -> &mut ::protobuf::RepeatedField<Access> {
        &mut self.accesses
    }

    // Take field
    pub fn take_accesses(&mut self) -> ::protobuf::RepeatedField<Access> {
        ::std::mem::replace(&mut self.accesses, ::protobuf::RepeatedField::new())
    }

    // repeated .CartesiCore.BracketNote brackets = 2;


    pub fn get_brackets(&self) -> &[BracketNote] {
        &self.brackets
    }
    pub fn clear_brackets(&mut self) {
        self.brackets.clear();
    }

    // Param is passed by value, moved
    pub fn set_brackets(&mut self, v: ::protobuf::RepeatedField<BracketNote>) {
        self.brackets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_brackets(&mut self) -> &mut ::protobuf::RepeatedField<BracketNote> {
        &mut self.brackets
    }

    // Take field
    pub fn take_brackets(&mut self) -> ::protobuf::RepeatedField<BracketNote> {
        ::std::mem::replace(&mut self.brackets, ::protobuf::RepeatedField::new())
    }

    // repeated string notes = 3;


    pub fn get_notes(&self) -> &[::std::string::String] {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.notes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccessLog {
    fn is_initialized(&self) -> bool {
        for v in &self.accesses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.brackets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accesses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.brackets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.brackets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accesses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.brackets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notes {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccessLog {
        AccessLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Access>>(
                    "accesses",
                    |m: &AccessLog| { &m.accesses },
                    |m: &mut AccessLog| { &mut m.accesses },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BracketNote>>(
                    "brackets",
                    |m: &AccessLog| { &m.brackets },
                    |m: &mut AccessLog| { &mut m.brackets },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "notes",
                    |m: &AccessLog| { &m.notes },
                    |m: &mut AccessLog| { &mut m.notes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccessLog>(
                    "AccessLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccessLog {
        static mut instance: ::protobuf::lazy::Lazy<AccessLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccessLog,
        };
        unsafe {
            instance.get(AccessLog::new)
        }
    }
}

impl ::protobuf::Clear for AccessLog {
    fn clear(&mut self) {
        self.accesses.clear();
        self.brackets.clear();
        self.notes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccessLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessLog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AccessOperation {
    READ = 0,
    WRITE = 1,
}

impl ::protobuf::ProtobufEnum for AccessOperation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessOperation> {
        match value {
            0 => ::std::option::Option::Some(AccessOperation::READ),
            1 => ::std::option::Option::Some(AccessOperation::WRITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccessOperation] = &[
            AccessOperation::READ,
            AccessOperation::WRITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AccessOperation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AccessOperation {
}

impl ::std::default::Default for AccessOperation {
    fn default() -> Self {
        AccessOperation::READ
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12cartesi-base.proto\x12\x0bCartesiCore\"\x06\n\x04Void\"\x20\n\x04H\
    ash\x12\x18\n\x07content\x18\x01\x20\x01(\x0cR\x07content\"\xdc\x10\n\
    \x0eProcessorState\x12\x10\n\x02x1\x18\x01\x20\x01(\x04H\0R\x02x1\x12\
    \x10\n\x02x2\x18\x02\x20\x01(\x04H\x01R\x02x2\x12\x10\n\x02x3\x18\x03\
    \x20\x01(\x04H\x02R\x02x3\x12\x10\n\x02x4\x18\x04\x20\x01(\x04H\x03R\x02\
    x4\x12\x10\n\x02x5\x18\x05\x20\x01(\x04H\x04R\x02x5\x12\x10\n\x02x6\x18\
    \x06\x20\x01(\x04H\x05R\x02x6\x12\x10\n\x02x7\x18\x07\x20\x01(\x04H\x06R\
    \x02x7\x12\x10\n\x02x8\x18\x08\x20\x01(\x04H\x07R\x02x8\x12\x10\n\x02x9\
    \x18\t\x20\x01(\x04H\x08R\x02x9\x12\x12\n\x03x10\x18\n\x20\x01(\x04H\tR\
    \x03x10\x12\x12\n\x03x11\x18\x0b\x20\x01(\x04H\nR\x03x11\x12\x12\n\x03x1\
    2\x18\x0c\x20\x01(\x04H\x0bR\x03x12\x12\x12\n\x03x13\x18\r\x20\x01(\x04H\
    \x0cR\x03x13\x12\x12\n\x03x14\x18\x0e\x20\x01(\x04H\rR\x03x14\x12\x12\n\
    \x03x15\x18\x0f\x20\x01(\x04H\x0eR\x03x15\x12\x12\n\x03x16\x18\x10\x20\
    \x01(\x04H\x0fR\x03x16\x12\x12\n\x03x17\x18\x11\x20\x01(\x04H\x10R\x03x1\
    7\x12\x12\n\x03x18\x18\x12\x20\x01(\x04H\x11R\x03x18\x12\x12\n\x03x19\
    \x18\x13\x20\x01(\x04H\x12R\x03x19\x12\x12\n\x03x20\x18\x14\x20\x01(\x04\
    H\x13R\x03x20\x12\x12\n\x03x21\x18\x15\x20\x01(\x04H\x14R\x03x21\x12\x12\
    \n\x03x22\x18\x16\x20\x01(\x04H\x15R\x03x22\x12\x12\n\x03x23\x18\x17\x20\
    \x01(\x04H\x16R\x03x23\x12\x12\n\x03x24\x18\x18\x20\x01(\x04H\x17R\x03x2\
    4\x12\x12\n\x03x25\x18\x19\x20\x01(\x04H\x18R\x03x25\x12\x12\n\x03x26\
    \x18\x1a\x20\x01(\x04H\x19R\x03x26\x12\x12\n\x03x27\x18\x1b\x20\x01(\x04\
    H\x1aR\x03x27\x12\x12\n\x03x28\x18\x1c\x20\x01(\x04H\x1bR\x03x28\x12\x12\
    \n\x03x29\x18\x1d\x20\x01(\x04H\x1cR\x03x29\x12\x12\n\x03x30\x18\x1e\x20\
    \x01(\x04H\x1dR\x03x30\x12\x12\n\x03x31\x18\x1f\x20\x01(\x04H\x1eR\x03x3\
    1\x12\x10\n\x02pc\x18\x20\x20\x01(\x04H\x1fR\x02pc\x12\x1e\n\tmvendorid\
    \x18!\x20\x01(\x04H\x20R\tmvendorid\x12\x1a\n\x07marchid\x18\"\x20\x01(\
    \x04H!R\x07marchid\x12\x18\n\x06mimpid\x18#\x20\x01(\x04H\"R\x06mimpid\
    \x12\x18\n\x06mcycle\x18$\x20\x01(\x04H#R\x06mcycle\x12\x1c\n\x08minstre\
    t\x18%\x20\x01(\x04H$R\x08minstret\x12\x1a\n\x07mstatus\x18&\x20\x01(\
    \x04H%R\x07mstatus\x12\x16\n\x05mtvec\x18'\x20\x01(\x04H&R\x05mtvec\x12\
    \x1c\n\x08mscratch\x18(\x20\x01(\x04H'R\x08mscratch\x12\x14\n\x04mepc\
    \x18)\x20\x01(\x04H(R\x04mepc\x12\x18\n\x06mcause\x18*\x20\x01(\x04H)R\
    \x06mcause\x12\x16\n\x05mtval\x18+\x20\x01(\x04H*R\x05mtval\x12\x14\n\
    \x04misa\x18,\x20\x01(\x04H+R\x04misa\x12\x12\n\x03mie\x18-\x20\x01(\x04\
    H,R\x03mie\x12\x12\n\x03mip\x18.\x20\x01(\x04H-R\x03mip\x12\x1a\n\x07med\
    eleg\x18/\x20\x01(\x04H.R\x07medeleg\x12\x1a\n\x07mideleg\x180\x20\x01(\
    \x04H/R\x07mideleg\x12\x20\n\nmcounteren\x181\x20\x01(\x04H0R\nmcountere\
    n\x12\x16\n\x05stvec\x182\x20\x01(\x04H1R\x05stvec\x12\x1c\n\x08sscratch\
    \x183\x20\x01(\x04H2R\x08sscratch\x12\x14\n\x04sepc\x184\x20\x01(\x04H3R\
    \x04sepc\x12\x18\n\x06scause\x185\x20\x01(\x04H4R\x06scause\x12\x16\n\
    \x05stval\x186\x20\x01(\x04H5R\x05stval\x12\x14\n\x04satp\x187\x20\x01(\
    \x04H6R\x04satp\x12\x20\n\nscounteren\x188\x20\x01(\x04H7R\nscounteren\
    \x12\x16\n\x05ilrsc\x189\x20\x01(\x04H8R\x05ilrsc\x12\x18\n\x06iflags\
    \x18:\x20\x01(\x04H9R\x06iflagsB\n\n\x08x1_oneofB\n\n\x08x2_oneofB\n\n\
    \x08x3_oneofB\n\n\x08x4_oneofB\n\n\x08x5_oneofB\n\n\x08x6_oneofB\n\n\x08\
    x7_oneofB\n\n\x08x8_oneofB\n\n\x08x9_oneofB\x0b\n\tx10_oneofB\x0b\n\tx11\
    _oneofB\x0b\n\tx12_oneofB\x0b\n\tx13_oneofB\x0b\n\tx14_oneofB\x0b\n\tx15\
    _oneofB\x0b\n\tx16_oneofB\x0b\n\tx17_oneofB\x0b\n\tx18_oneofB\x0b\n\tx19\
    _oneofB\x0b\n\tx20_oneofB\x0b\n\tx21_oneofB\x0b\n\tx22_oneofB\x0b\n\tx23\
    _oneofB\x0b\n\tx24_oneofB\x0b\n\tx25_oneofB\x0b\n\tx26_oneofB\x0b\n\tx27\
    _oneofB\x0b\n\tx28_oneofB\x0b\n\tx29_oneofB\x0b\n\tx30_oneofB\x0b\n\tx31\
    _oneofB\n\n\x08pc_oneofB\x11\n\x0fmvendorid_oneofB\x0f\n\rmarchid_oneofB\
    \x0e\n\x0cmimpid_oneofB\x0e\n\x0cmcycle_oneofB\x10\n\x0eminstret_oneofB\
    \x0f\n\rmstatus_oneofB\r\n\x0bmtvec_oneofB\x10\n\x0emscratch_oneofB\x0c\
    \n\nmepc_oneofB\x0e\n\x0cmcause_oneofB\r\n\x0bmtval_oneofB\x0c\n\nmisa_o\
    neofB\x0b\n\tmie_oneofB\x0b\n\tmip_oneofB\x0f\n\rmedeleg_oneofB\x0f\n\rm\
    ideleg_oneofB\x12\n\x10mcounteren_oneofB\r\n\x0bstvec_oneofB\x10\n\x0ess\
    cratch_oneofB\x0c\n\nsepc_oneofB\x0e\n\x0cscause_oneofB\r\n\x0bstval_one\
    ofB\x0c\n\nsatp_oneofB\x12\n\x10scounteren_oneofB\r\n\x0bilrsc_oneofB\
    \x0e\n\x0ciflags_oneof\"o\n\tProcessor\x123\n\x05state\x18\x01\x20\x01(\
    \x0b2\x1b.CartesiCore.ProcessorStateH\0R\x05state\x12\x1a\n\x07backing\
    \x18\x02\x20\x01(\tH\0R\x07backingB\x11\n\x0fprocessor_oneof\"L\n\x03ROM\
    \x12\x1c\n\x08bootargs\x18\x01\x20\x01(\tH\0R\x08bootargs\x12\x1a\n\x07b\
    acking\x18\x02\x20\x01(\tH\0R\x07backingB\x0b\n\trom_oneof\"7\n\x03RAM\
    \x12\x16\n\x06length\x18\x01\x20\x01(\x04R\x06length\x12\x18\n\x07backin\
    g\x18\x02\x20\x01(\tR\x07backing\"}\n\x05Drive\x12\x14\n\x05start\x18\
    \x01\x20\x01(\x04R\x05start\x12\x16\n\x06length\x18\x02\x20\x01(\x04R\
    \x06length\x12\x18\n\x07backing\x18\x03\x20\x01(\tR\x07backing\x12\x16\n\
    \x06shared\x18\x04\x20\x01(\x08R\x06shared\x12\x14\n\x05label\x18\x05\
    \x20\x01(\tR\x05label\">\n\nCLINTState\x12\x14\n\x05mtime\x18\x01\x20\
    \x01(\x04R\x05mtime\x12\x1a\n\x08mtimecmp\x18\x02\x20\x01(\x04R\x08mtime\
    cmp\"c\n\x05CLINT\x12/\n\x05state\x18\x01\x20\x01(\x0b2\x17.CartesiCore.\
    CLINTStateH\0R\x05state\x12\x1a\n\x07backing\x18\x02\x20\x01(\tH\0R\x07b\
    ackingB\r\n\x0bclint_oneof\"?\n\tHTIFState\x12\x1a\n\x08fromhost\x18\x01\
    \x20\x01(\x04R\x08fromhost\x12\x16\n\x06tohost\x18\x02\x20\x01(\x04R\x06\
    tohost\"`\n\x04HTIF\x12.\n\x05state\x18\x01\x20\x01(\x0b2\x16.CartesiCor\
    e.HTIFStateH\0R\x05state\x12\x1a\n\x07backing\x18\x02\x20\x01(\tH\0R\x07\
    backingB\x0c\n\nhtif_oneof\"\x89\x02\n\x0eMachineRequest\x124\n\tprocess\
    or\x18\x01\x20\x01(\x0b2\x16.CartesiCore.ProcessorR\tprocessor\x12\"\n\
    \x03rom\x18\x02\x20\x01(\x0b2\x10.CartesiCore.ROMR\x03rom\x12\"\n\x03ram\
    \x18\x03\x20\x01(\x0b2\x10.CartesiCore.RAMR\x03ram\x12(\n\x05flash\x18\
    \x04\x20\x03(\x0b2\x12.CartesiCore.DriveR\x05flash\x12(\n\x05clint\x18\
    \x05\x20\x01(\x0b2\x12.CartesiCore.CLINTR\x05clint\x12%\n\x04htif\x18\
    \x06\x20\x01(\x0b2\x11.CartesiCore.HTIFR\x04htif\"\"\n\nRunRequest\x12\
    \x14\n\x05limit\x18\x01\x20\x01(\x04R\x05limit\"=\n\x0bRunResponse\x12\
    \x16\n\x06mcycle\x18\x01\x20\x01(\x04R\x06mcycle\x12\x16\n\x06tohost\x18\
    \x02\x20\x01(\x04R\x06tohost\"\xdc\x01\n\x05Proof\x12\x18\n\x07address\
    \x18\x01\x20\x01(\x04R\x07address\x12\x1b\n\tlog2_size\x18\x02\x20\x01(\
    \rR\x08log2Size\x122\n\x0btarget_hash\x18\x03\x20\x01(\x0b2\x11.CartesiC\
    ore.HashR\ntargetHash\x128\n\x0esibling_hashes\x18\x04\x20\x03(\x0b2\x11\
    .CartesiCore.HashR\rsiblingHashes\x12.\n\troot_hash\x18\x05\x20\x01(\x0b\
    2\x11.CartesiCore.HashR\x08rootHash\"\x20\n\x04Word\x12\x18\n\x07content\
    \x18\x01\x20\x01(\x0cR\x07content\"\xc2\x01\n\x06Access\x12:\n\toperatio\
    n\x18\x01\x20\x01(\x0e2\x1c.CartesiCore.AccessOperationR\toperation\x12%\
    \n\x04read\x18\x02\x20\x01(\x0b2\x11.CartesiCore.WordR\x04read\x12+\n\
    \x07written\x18\x03\x20\x01(\x0b2\x11.CartesiCore.WordR\x07written\x12(\
    \n\x05proof\x18\x04\x20\x01(\x0b2\x12.CartesiCore.ProofR\x05proof\"\xb4\
    \x01\n\x0bBracketNote\x12<\n\x04type\x18\x01\x20\x01(\x0e2(.CartesiCore.\
    BracketNote.BracketNoteTypeR\x04type\x12\x14\n\x05where\x18\x02\x20\x01(\
    \x04R\x05where\x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\"=\n\x0fBra\
    cketNoteType\x12\t\n\x05DUMMY\x10\0\x12\t\n\x05BEGIN\x10\x01\x12\x07\n\
    \x03END\x10\x02\x12\x0b\n\x07INVALID\x10\x03\"E\n\x11ReadMemoryRequest\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06leng\
    th\x18\x02\x20\x01(\x04R\x06length\"(\n\x12ReadMemoryResponse\x12\x12\n\
    \x04data\x18\x01\x20\x01(\x0cR\x04data\"H\n\x0fGetProofRequest\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x04R\x07address\x12\x1b\n\tlog2_size\x18\
    \x02\x20\x01(\x04R\x08log2Size\"B\n\x12WriteMemoryRequest\x12\x18\n\x07a\
    ddress\x18\x01\x20\x01(\x04R\x07address\x12\x12\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04data\"\x88\x01\n\tAccessLog\x12/\n\x08accesses\x18\x01\x20\
    \x03(\x0b2\x13.CartesiCore.AccessR\x08accesses\x124\n\x08brackets\x18\
    \x02\x20\x03(\x0b2\x18.CartesiCore.BracketNoteR\x08brackets\x12\x14\n\
    \x05notes\x18\x03\x20\x03(\tR\x05notes*&\n\x0fAccessOperation\x12\x08\n\
    \x04READ\x10\0\x12\t\n\x05WRITE\x10\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
